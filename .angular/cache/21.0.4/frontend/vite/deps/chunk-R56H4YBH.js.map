{
  "version": 3,
  "sources": ["../../../../../../node_modules/@apollo/client/incremental/handlers/notImplemented.js", "../../../../../../node_modules/@apollo/client/cache/core/cache.js", "../../../../../../node_modules/@apollo/client/cache/core/types/common.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/helpers.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/entityStore.js", "../../../../../../node_modules/@apollo/client/masking/utils.js", "../../../../../../node_modules/@apollo/client/masking/maskDefinition.js", "../../../../../../node_modules/@apollo/client/masking/maskFragment.js", "../../../../../../node_modules/@apollo/client/masking/maskOperation.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/key-extractor.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/reactiveVars.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/policies.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/readFromStore.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/writeToStore.js", "../../../../../../node_modules/@apollo/client/cache/inmemory/inMemoryCache.js", "../../../../../../node_modules/@apollo/client/core/networkStatus.js", "../../../../../../node_modules/@apollo/client/core/ObservableQuery.js", "../../../../../../node_modules/@apollo/client/core/QueryInfo.js", "../../../../../../node_modules/@apollo/client/core/QueryManager.js", "../../../../../../node_modules/@apollo/client/core/ApolloClient.js", "../../../../../../node_modules/graphql-tag/lib/index.js"],
  "sourcesContent": ["import { hasDirectives } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nexport class NotImplementedHandler {\n    isIncrementalResult(_) {\n        return false;\n    }\n    prepareRequest(request) {\n        invariant(!hasDirectives([\"defer\"], request.query), 64);\n        return request;\n    }\n    extractErrors() { }\n    // This code path can never be reached, so we won't implement it.\n    startRequest = undefined;\n}\n\n", "import { WeakCache } from \"@wry/caches\";\nimport { wrap } from \"optimism\";\nimport { Observable } from \"rxjs\";\nimport { cacheSizes } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { equalByQuery, getApolloCacheMemoryInternals, getFragmentDefinition, getFragmentQueryDocument, } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nexport class ApolloCache {\n    assumeImmutableResults = false;\n    // Function used to lookup a fragment when a fragment definition is not part\n    // of the GraphQL document. This is useful for caches, such as InMemoryCache,\n    // that register fragments ahead of time so they can be referenced by name.\n    lookupFragment(fragmentName) {\n        return null;\n    }\n    // Transactional API\n    // The batch method is intended to replace/subsume both performTransaction\n    // and recordOptimisticTransaction, but performTransaction came first, so we\n    // provide a default batch implementation that's just another way of calling\n    // performTransaction. Subclasses of ApolloCache (such as InMemoryCache) can\n    // override the batch method to do more interesting things with its options.\n    batch(options) {\n        const optimisticId = typeof options.optimistic === \"string\" ? options.optimistic\n            : options.optimistic === false ? null\n                : void 0;\n        let updateResult;\n        this.performTransaction(() => (updateResult = options.update(this)), optimisticId);\n        return updateResult;\n    }\n    recordOptimisticTransaction(transaction, optimisticId) {\n        this.performTransaction(transaction, optimisticId);\n    }\n    // Optional API\n    // Called once per input document, allowing the cache to make static changes\n    // to the query, such as adding __typename fields.\n    transformDocument(document) {\n        return document;\n    }\n    // Called before each ApolloLink request, allowing the cache to make dynamic\n    // changes to the query, such as filling in missing fragment definitions.\n    transformForLink(document) {\n        return document;\n    }\n    identify(object) {\n        return;\n    }\n    gc() {\n        return [];\n    }\n    modify(options) {\n        return false;\n    }\n    readQuery(options, optimistic = !!options.optimistic) {\n        return this.read({\n            ...options,\n            rootId: options.id || \"ROOT_QUERY\",\n            optimistic,\n        });\n    }\n    /**\n    * Watches the cache store of the fragment according to the options specified\n    * and returns an `Observable`. We can subscribe to this\n    * `Observable` and receive updated results through an\n    * observer when the cache store changes.\n    * \n    * You must pass in a GraphQL document with a single fragment or a document\n    * with multiple fragments that represent what you are reading. If you pass\n    * in a document with multiple fragments then you must also specify a\n    * `fragmentName`.\n    * \n    * @since 3.10.0\n    * @param options - An object of type `WatchFragmentOptions` that allows\n    * the cache to identify the fragment and optionally specify whether to react\n    * to optimistic updates.\n    */\n    watchFragment(options) {\n        const { fragment, fragmentName, from, optimistic = true, ...otherOptions } = options;\n        const query = this.getFragmentDoc(fragment, fragmentName);\n        // While our TypeScript types do not allow for `undefined` as a valid\n        // `from`, its possible `useFragment` gives us an `undefined` since it\n        // calls` cache.identify` and provides that value to `from`. We are\n        // adding this fix here however to ensure those using plain JavaScript\n        // and using `cache.identify` themselves will avoid seeing the obscure\n        // warning.\n        const id = typeof from === \"undefined\" || typeof from === \"string\" ?\n            from\n            : this.identify(from);\n        if (__DEV__) {\n            const actualFragmentName = fragmentName || getFragmentDefinition(fragment).name.value;\n            if (!id) {\n                __DEV__ && invariant.warn(110, actualFragmentName);\n            }\n        }\n        const diffOptions = {\n            ...otherOptions,\n            returnPartialData: true,\n            id,\n            query,\n            optimistic,\n        };\n        let latestDiff;\n        return new Observable((observer) => {\n            return this.watch({\n                ...diffOptions,\n                immediate: true,\n                callback: (diff) => {\n                    let data = diff.result;\n                    // TODO: Remove this once `watchFragment` supports `null` as valid\n                    // value emitted\n                    if (data === null) {\n                        data = {};\n                    }\n                    if (\n                    // Always ensure we deliver the first result\n                    latestDiff &&\n                        equalByQuery(query, { data: latestDiff.result }, { data }, options.variables)) {\n                        return;\n                    }\n                    const result = {\n                        data,\n                        dataState: diff.complete ? \"complete\" : \"partial\",\n                        complete: !!diff.complete,\n                    };\n                    if (diff.missing) {\n                        result.missing = diff.missing.missing;\n                    }\n                    latestDiff = { ...diff, result: data };\n                    observer.next(result);\n                },\n            });\n        });\n    }\n    // Make sure we compute the same (===) fragment query document every\n    // time we receive the same fragment in readFragment.\n    getFragmentDoc = wrap(getFragmentQueryDocument, {\n        max: cacheSizes[\"cache.fragmentQueryDocuments\"] ||\n            1000 /* defaultCacheSizes[\"cache.fragmentQueryDocuments\"] */,\n        cache: WeakCache,\n    });\n    readFragment(options, optimistic = !!options.optimistic) {\n        return this.read({\n            ...options,\n            query: this.getFragmentDoc(options.fragment, options.fragmentName),\n            rootId: options.id,\n            optimistic,\n        });\n    }\n    writeQuery({ id, data, ...options }) {\n        return this.write(Object.assign(options, {\n            dataId: id || \"ROOT_QUERY\",\n            result: data,\n        }));\n    }\n    writeFragment({ id, data, fragment, fragmentName, ...options }) {\n        return this.write(Object.assign(options, {\n            query: this.getFragmentDoc(fragment, fragmentName),\n            dataId: id,\n            result: data,\n        }));\n    }\n    updateQuery(options, update) {\n        return this.batch({\n            update(cache) {\n                const value = cache.readQuery(options);\n                const data = update(value);\n                if (data === void 0 || data === null)\n                    return value;\n                cache.writeQuery({ ...options, data });\n                return data;\n            },\n        });\n    }\n    updateFragment(options, update) {\n        return this.batch({\n            update(cache) {\n                const value = cache.readFragment(options);\n                const data = update(value);\n                if (data === void 0 || data === null)\n                    return value;\n                cache.writeFragment({ ...options, data });\n                return data;\n            },\n        });\n    }\n}\nif (__DEV__) {\n    ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;\n}\n\n", "export class MissingFieldError extends Error {\n    message;\n    path;\n    query;\n    variables;\n    constructor(message, path, query, variables) {\n        // 'Error' breaks prototype chain here\n        super(message);\n        this.message = message;\n        this.path = path;\n        this.query = query;\n        this.variables = variables;\n        this.name = \"MissingFieldError\";\n        if (Array.isArray(this.path)) {\n            this.missing = this.message;\n            for (let i = this.path.length - 1; i >= 0; --i) {\n                this.missing = { [this.path[i]]: this.missing };\n            }\n        }\n        else {\n            this.missing = this.path;\n        }\n        // We're not using `Object.setPrototypeOf` here as it isn't fully supported\n        // on Android (see issue #3236).\n        this.__proto__ = MissingFieldError.prototype;\n    }\n    missing;\n}\n", "import { isReference } from \"@apollo/client/utilities\";\nimport { compact, createFragmentMap, DeepMerger, getFragmentDefinitions, isArray, isField, isNonNullObject, resultKeyNameFromField, shouldInclude, } from \"@apollo/client/utilities/internal\";\nexport const { hasOwnProperty: hasOwn } = Object.prototype;\nexport function defaultDataIdFromObject({ __typename, id, _id }, context) {\n    if (typeof __typename === \"string\") {\n        if (context) {\n            context.keyObject =\n                id != null ? { id }\n                    : _id != null ? { _id }\n                        : void 0;\n        }\n        // If there is no object.id, fall back to object._id.\n        if (id == null && _id != null) {\n            id = _id;\n        }\n        if (id != null) {\n            return `${__typename}:${typeof id === \"number\" || typeof id === \"string\" ?\n                id\n                : JSON.stringify(id)}`;\n        }\n    }\n}\nconst defaultConfig = {\n    dataIdFromObject: defaultDataIdFromObject,\n    resultCaching: true,\n};\nexport function normalizeConfig(config) {\n    return compact(defaultConfig, config);\n}\nexport function getTypenameFromStoreObject(store, objectOrReference) {\n    return isReference(objectOrReference) ?\n        store.get(objectOrReference.__ref, \"__typename\")\n        : objectOrReference && objectOrReference.__typename;\n}\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\nexport function fieldNameFromStoreName(storeFieldName) {\n    const match = storeFieldName.match(TypeOrFieldNameRegExp);\n    return match ? match[0] : storeFieldName;\n}\nexport function selectionSetMatchesResult(selectionSet, result, variables) {\n    if (isNonNullObject(result)) {\n        return isArray(result) ?\n            result.every((item) => selectionSetMatchesResult(selectionSet, item, variables))\n            : selectionSet.selections.every((field) => {\n                if (isField(field) && shouldInclude(field, variables)) {\n                    const key = resultKeyNameFromField(field);\n                    return (hasOwn.call(result, key) &&\n                        (!field.selectionSet ||\n                            selectionSetMatchesResult(field.selectionSet, result[key], variables)));\n                }\n                // If the selection has been skipped with @skip(true) or\n                // @include(false), it should not count against the matching. If\n                // the selection is not a field, it must be a fragment (inline or\n                // named). We will determine if selectionSetMatchesResult for that\n                // fragment when we get to it, so for now we return true.\n                return true;\n            });\n    }\n    return false;\n}\nexport function storeValueIsStoreObject(value) {\n    return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\nexport function makeProcessedFieldsMerger() {\n    return new DeepMerger();\n}\nexport function extractFragmentContext(document, fragments) {\n    // FragmentMap consisting only of fragments defined directly in document, not\n    // including other fragments registered in the FragmentRegistry.\n    const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n    return {\n        fragmentMap,\n        lookupFragment(name) {\n            let def = fragmentMap[name];\n            if (!def && fragments) {\n                def = fragments.lookup(name);\n            }\n            return def || null;\n        },\n    };\n}\n", "import { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport { dep } from \"optimism\";\nimport { isReference } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { DeepMerger, isNonNullObject, makeReference, maybeDeepFreeze, } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { fieldNameFromStoreName, hasOwn } from \"./helpers.js\";\nconst DELETE = {};\nconst delModifier = () => DELETE;\nconst INVALIDATE = {};\nexport class EntityStore {\n    policies;\n    group;\n    data = {};\n    constructor(policies, group) {\n        this.policies = policies;\n        this.group = group;\n    }\n    // Although the EntityStore class is abstract, it contains concrete\n    // implementations of the various NormalizedCache interface methods that\n    // are inherited by the Root and Layer subclasses.\n    toObject() {\n        return { ...this.data };\n    }\n    has(dataId) {\n        return this.lookup(dataId, true) !== void 0;\n    }\n    get(dataId, fieldName) {\n        this.group.depend(dataId, fieldName);\n        if (hasOwn.call(this.data, dataId)) {\n            const storeObject = this.data[dataId];\n            if (storeObject && hasOwn.call(storeObject, fieldName)) {\n                return storeObject[fieldName];\n            }\n        }\n        if (fieldName === \"__typename\" &&\n            hasOwn.call(this.policies.rootTypenamesById, dataId)) {\n            return this.policies.rootTypenamesById[dataId];\n        }\n        if (this instanceof Layer) {\n            return this.parent.get(dataId, fieldName);\n        }\n    }\n    lookup(dataId, dependOnExistence) {\n        // The has method (above) calls lookup with dependOnExistence = true, so\n        // that it can later be invalidated when we add or remove a StoreObject for\n        // this dataId. Any consumer who cares about the contents of the StoreObject\n        // should not rely on this dependency, since the contents could change\n        // without the object being added or removed.\n        if (dependOnExistence)\n            this.group.depend(dataId, \"__exists\");\n        if (hasOwn.call(this.data, dataId)) {\n            return this.data[dataId];\n        }\n        if (this instanceof Layer) {\n            return this.parent.lookup(dataId, dependOnExistence);\n        }\n        if (this.policies.rootTypenamesById[dataId]) {\n            return {};\n        }\n    }\n    merge(older, newer) {\n        let dataId;\n        // Convert unexpected references to ID strings.\n        if (isReference(older))\n            older = older.__ref;\n        if (isReference(newer))\n            newer = newer.__ref;\n        const existing = typeof older === \"string\" ? this.lookup((dataId = older)) : older;\n        const incoming = typeof newer === \"string\" ? this.lookup((dataId = newer)) : newer;\n        // If newer was a string ID, but that ID was not defined in this store,\n        // then there are no fields to be merged, so we're done.\n        if (!incoming)\n            return;\n        invariant(typeof dataId === \"string\", 96);\n        const merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);\n        // Even if merged === existing, existing may have come from a lower\n        // layer, so we always need to set this.data[dataId] on this level.\n        this.data[dataId] = merged;\n        if (merged !== existing) {\n            delete this.refs[dataId];\n            if (this.group.caching) {\n                const fieldsToDirty = {};\n                // If we added a new StoreObject where there was previously none, dirty\n                // anything that depended on the existence of this dataId, such as the\n                // EntityStore#has method.\n                if (!existing)\n                    fieldsToDirty.__exists = 1;\n                // Now invalidate dependents who called getFieldValue for any fields\n                // that are changing as a result of this merge.\n                Object.keys(incoming).forEach((storeFieldName) => {\n                    if (!existing ||\n                        existing[storeFieldName] !== merged[storeFieldName]) {\n                        // Always dirty the full storeFieldName, which may include\n                        // serialized arguments following the fieldName prefix.\n                        fieldsToDirty[storeFieldName] = 1;\n                        // Also dirty fieldNameFromStoreName(storeFieldName) if it's\n                        // different from storeFieldName and this field does not have\n                        // keyArgs configured, because that means the cache can't make\n                        // any assumptions about how field values with the same field\n                        // name but different arguments might be interrelated, so it\n                        // must err on the side of invalidating all field values that\n                        // share the same short fieldName, regardless of arguments.\n                        const fieldName = fieldNameFromStoreName(storeFieldName);\n                        if (fieldName !== storeFieldName &&\n                            !this.policies.hasKeyArgs(merged.__typename, fieldName)) {\n                            fieldsToDirty[fieldName] = 1;\n                        }\n                        // If merged[storeFieldName] has become undefined, and this is the\n                        // Root layer, actually delete the property from the merged object,\n                        // which is guaranteed to have been created fresh in this method.\n                        if (merged[storeFieldName] === void 0 && !(this instanceof Layer)) {\n                            delete merged[storeFieldName];\n                        }\n                    }\n                });\n                if (fieldsToDirty.__typename &&\n                    !(existing && existing.__typename) &&\n                    // Since we return default root __typename strings\n                    // automatically from store.get, we don't need to dirty the\n                    // ROOT_QUERY.__typename field if merged.__typename is equal\n                    // to the default string (usually \"Query\").\n                    this.policies.rootTypenamesById[dataId] === merged.__typename) {\n                    delete fieldsToDirty.__typename;\n                }\n                Object.keys(fieldsToDirty).forEach((fieldName) => this.group.dirty(dataId, fieldName));\n            }\n        }\n    }\n    modify(dataId, fields, exact) {\n        const storeObject = this.lookup(dataId);\n        if (storeObject) {\n            const changedFields = {};\n            let needToMerge = false;\n            let allDeleted = true;\n            const sharedDetails = {\n                DELETE,\n                INVALIDATE,\n                isReference,\n                toReference: this.toReference,\n                canRead: this.canRead,\n                readField: (fieldNameOrOptions, from) => this.policies.readField(typeof fieldNameOrOptions === \"string\" ?\n                    {\n                        fieldName: fieldNameOrOptions,\n                        from: from || makeReference(dataId),\n                    }\n                    : fieldNameOrOptions, { store: this }),\n            };\n            Object.keys(storeObject).forEach((storeFieldName) => {\n                const fieldName = fieldNameFromStoreName(storeFieldName);\n                let fieldValue = storeObject[storeFieldName];\n                if (fieldValue === void 0)\n                    return;\n                const modify = typeof fields === \"function\" ? fields : (fields[storeFieldName] || (exact ? undefined : fields[fieldName]));\n                if (modify) {\n                    let newValue = modify === delModifier ? DELETE : (modify(maybeDeepFreeze(fieldValue), {\n                        ...sharedDetails,\n                        fieldName,\n                        storeFieldName,\n                        storage: this.getStorage(dataId, storeFieldName),\n                    }));\n                    if (newValue === INVALIDATE) {\n                        this.group.dirty(dataId, storeFieldName);\n                    }\n                    else {\n                        if (newValue === DELETE)\n                            newValue = void 0;\n                        if (newValue !== fieldValue) {\n                            changedFields[storeFieldName] = newValue;\n                            needToMerge = true;\n                            fieldValue = newValue;\n                            if (__DEV__) {\n                                const checkReference = (ref) => {\n                                    if (this.lookup(ref.__ref) === undefined) {\n                                        __DEV__ && invariant.warn(97, ref);\n                                        return true;\n                                    }\n                                };\n                                if (isReference(newValue)) {\n                                    checkReference(newValue);\n                                }\n                                else if (Array.isArray(newValue)) {\n                                    // Warn about writing \"mixed\" arrays of Reference and non-Reference objects\n                                    let seenReference = false;\n                                    let someNonReference;\n                                    for (const value of newValue) {\n                                        if (isReference(value)) {\n                                            seenReference = true;\n                                            if (checkReference(value))\n                                                break;\n                                        }\n                                        else {\n                                            // Do not warn on primitive values, since those could never be represented\n                                            // by a reference. This is a valid (albeit uncommon) use case.\n                                            if (typeof value === \"object\" && !!value) {\n                                                const [id] = this.policies.identify(value);\n                                                // check if object could even be referenced, otherwise we are not interested in it for this warning\n                                                if (id) {\n                                                    someNonReference = value;\n                                                }\n                                            }\n                                        }\n                                        if (seenReference && someNonReference !== undefined) {\n                                            __DEV__ && invariant.warn(98, someNonReference);\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (fieldValue !== void 0) {\n                    allDeleted = false;\n                }\n            });\n            if (needToMerge) {\n                this.merge(dataId, changedFields);\n                if (allDeleted) {\n                    if (this instanceof Layer) {\n                        this.data[dataId] = void 0;\n                    }\n                    else {\n                        delete this.data[dataId];\n                    }\n                    this.group.dirty(dataId, \"__exists\");\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // If called with only one argument, removes the entire entity\n    // identified by dataId. If called with a fieldName as well, removes all\n    // fields of that entity whose names match fieldName according to the\n    // fieldNameFromStoreName helper function. If called with a fieldName\n    // and variables, removes all fields of that entity whose names match fieldName\n    // and whose arguments when cached exactly match the variables passed.\n    delete(dataId, fieldName, args) {\n        const storeObject = this.lookup(dataId);\n        if (storeObject) {\n            const typename = this.getFieldValue(storeObject, \"__typename\");\n            const storeFieldName = fieldName && args ?\n                this.policies.getStoreFieldName({ typename, fieldName, args })\n                : fieldName;\n            return this.modify(dataId, storeFieldName ?\n                {\n                    [storeFieldName]: delModifier,\n                }\n                : delModifier, !!args);\n        }\n        return false;\n    }\n    evict(options, limit) {\n        let evicted = false;\n        if (options.id) {\n            if (hasOwn.call(this.data, options.id)) {\n                evicted = this.delete(options.id, options.fieldName, options.args);\n            }\n            if (this instanceof Layer && this !== limit) {\n                evicted = this.parent.evict(options, limit) || evicted;\n            }\n            // Always invalidate the field to trigger rereading of watched\n            // queries, even if no cache data was modified by the eviction,\n            // because queries may depend on computed fields with custom read\n            // functions, whose values are not stored in the EntityStore.\n            if (options.fieldName || evicted) {\n                this.group.dirty(options.id, options.fieldName || \"__exists\");\n            }\n        }\n        return evicted;\n    }\n    clear() {\n        this.replace(null);\n    }\n    extract() {\n        const obj = this.toObject();\n        const extraRootIds = [];\n        this.getRootIdSet().forEach((id) => {\n            if (!hasOwn.call(this.policies.rootTypenamesById, id)) {\n                extraRootIds.push(id);\n            }\n        });\n        if (extraRootIds.length) {\n            obj.__META = { extraRootIds: extraRootIds.sort() };\n        }\n        return obj;\n    }\n    replace(newData) {\n        Object.keys(this.data).forEach((dataId) => {\n            if (!(newData && hasOwn.call(newData, dataId))) {\n                this.delete(dataId);\n            }\n        });\n        if (newData) {\n            const { __META, ...rest } = newData;\n            Object.keys(rest).forEach((dataId) => {\n                this.merge(dataId, rest[dataId]);\n            });\n            if (__META) {\n                __META.extraRootIds.forEach(this.retain, this);\n            }\n        }\n    }\n    // Maps root entity IDs to the number of times they have been retained, minus\n    // the number of times they have been released. Retained entities keep other\n    // entities they reference (even indirectly) from being garbage collected.\n    rootIds = {};\n    retain(rootId) {\n        return (this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1);\n    }\n    release(rootId) {\n        if (this.rootIds[rootId] > 0) {\n            const count = --this.rootIds[rootId];\n            if (!count)\n                delete this.rootIds[rootId];\n            return count;\n        }\n        return 0;\n    }\n    // Return a Set<string> of all the ID strings that have been retained by\n    // this layer/root *and* any layers/roots beneath it.\n    getRootIdSet(ids = new Set()) {\n        Object.keys(this.rootIds).forEach(ids.add, ids);\n        if (this instanceof Layer) {\n            this.parent.getRootIdSet(ids);\n        }\n        else {\n            // Official singleton IDs like ROOT_QUERY and ROOT_MUTATION are\n            // always considered roots for garbage collection, regardless of\n            // their retainment counts in this.rootIds.\n            Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n        }\n        return ids;\n    }\n    // The goal of garbage collection is to remove IDs from the Root layer of the\n    // store that are no longer reachable starting from any IDs that have been\n    // explicitly retained (see retain and release, above). Returns an array of\n    // dataId strings that were removed from the store.\n    gc() {\n        const ids = this.getRootIdSet();\n        const snapshot = this.toObject();\n        ids.forEach((id) => {\n            if (hasOwn.call(snapshot, id)) {\n                // Because we are iterating over an ECMAScript Set, the IDs we add here\n                // will be visited in later iterations of the forEach loop only if they\n                // were not previously contained by the Set.\n                Object.keys(this.findChildRefIds(id)).forEach(ids.add, ids);\n                // By removing IDs from the snapshot object here, we protect them from\n                // getting removed from the root store layer below.\n                delete snapshot[id];\n            }\n        });\n        const idsToRemove = Object.keys(snapshot);\n        if (idsToRemove.length) {\n            let root = this;\n            while (root instanceof Layer)\n                root = root.parent;\n            idsToRemove.forEach((id) => root.delete(id));\n        }\n        return idsToRemove;\n    }\n    // Lazily tracks { __ref: <dataId> } strings contained by this.data[dataId].\n    refs = {};\n    findChildRefIds(dataId) {\n        if (!hasOwn.call(this.refs, dataId)) {\n            const found = (this.refs[dataId] = {});\n            const root = this.data[dataId];\n            if (!root)\n                return found;\n            const workSet = new Set([root]);\n            // Within the store, only arrays and objects can contain child entity\n            // references, so we can prune the traversal using this predicate:\n            workSet.forEach((obj) => {\n                if (isReference(obj)) {\n                    found[obj.__ref] = true;\n                    // In rare cases, a { __ref } Reference object may have other fields.\n                    // This often indicates a mismerging of References with StoreObjects,\n                    // but garbage collection should not be fooled by a stray __ref\n                    // property in a StoreObject (ignoring all the other fields just\n                    // because the StoreObject looks like a Reference). To avoid this\n                    // premature termination of findChildRefIds recursion, we fall through\n                    // to the code below, which will handle any other properties of obj.\n                }\n                if (isNonNullObject(obj)) {\n                    Object.keys(obj).forEach((key) => {\n                        const child = obj[key];\n                        // No need to add primitive values to the workSet, since they cannot\n                        // contain reference objects.\n                        if (isNonNullObject(child)) {\n                            workSet.add(child);\n                        }\n                    });\n                }\n            });\n        }\n        return this.refs[dataId];\n    }\n    makeCacheKey() {\n        return this.group.keyMaker.lookupArray(arguments);\n    }\n    // Bound function that can be passed around to provide easy access to fields\n    // of Reference objects as well as ordinary objects.\n    getFieldValue = (objectOrReference, storeFieldName) => maybeDeepFreeze(isReference(objectOrReference) ?\n        this.get(objectOrReference.__ref, storeFieldName)\n        : objectOrReference && objectOrReference[storeFieldName]);\n    // Returns true for non-normalized StoreObjects and non-dangling\n    // References, indicating that readField(name, objOrRef) has a chance of\n    // working. Useful for filtering out dangling references from lists.\n    canRead = (objOrRef) => {\n        return isReference(objOrRef) ?\n            this.has(objOrRef.__ref)\n            : typeof objOrRef === \"object\";\n    };\n    // Bound function that converts an id or an object with a __typename and\n    // primary key fields to a Reference object. If called with a Reference object,\n    // that same Reference object is returned. Pass true for mergeIntoStore to persist\n    // an object into the store.\n    toReference = (objOrIdOrRef, mergeIntoStore) => {\n        if (typeof objOrIdOrRef === \"string\") {\n            return makeReference(objOrIdOrRef);\n        }\n        if (isReference(objOrIdOrRef)) {\n            return objOrIdOrRef;\n        }\n        const [id] = this.policies.identify(objOrIdOrRef);\n        if (id) {\n            const ref = makeReference(id);\n            if (mergeIntoStore) {\n                this.merge(id, objOrIdOrRef);\n            }\n            return ref;\n        }\n    };\n    get supportsResultCaching() {\n        return this.group.caching;\n    }\n}\n// A single CacheGroup represents a set of one or more EntityStore objects,\n// typically the Root store in a CacheGroup by itself, and all active Layer\n// stores in a group together. A single EntityStore object belongs to only\n// one CacheGroup, store.group. The CacheGroup is responsible for tracking\n// dependencies, so store.group is helpful for generating unique keys for\n// cached results that need to be invalidated when/if those dependencies\n// change. If we used the EntityStore objects themselves as cache keys (that\n// is, store rather than store.group), the cache would become unnecessarily\n// fragmented by all the different Layer objects. Instead, the CacheGroup\n// approach allows all optimistic Layer objects in the same linked list to\n// belong to one CacheGroup, with the non-optimistic Root object belonging\n// to another CacheGroup, allowing resultCaching dependencies to be tracked\n// separately for optimistic and non-optimistic entity data.\nclass CacheGroup {\n    caching;\n    parent;\n    d = null;\n    // Used by the EntityStore#makeCacheKey method to compute cache keys\n    // specific to this CacheGroup.\n    keyMaker;\n    constructor(caching, parent = null) {\n        this.caching = caching;\n        this.parent = parent;\n        this.resetCaching();\n    }\n    resetCaching() {\n        this.d = this.caching ? dep() : null;\n        this.keyMaker = new Trie();\n    }\n    depend(dataId, storeFieldName) {\n        if (this.d) {\n            this.d(makeDepKey(dataId, storeFieldName));\n            const fieldName = fieldNameFromStoreName(storeFieldName);\n            if (fieldName !== storeFieldName) {\n                // Fields with arguments that contribute extra identifying\n                // information to the fieldName (thus forming the storeFieldName)\n                // depend not only on the full storeFieldName but also on the\n                // short fieldName, so the field can be invalidated using either\n                // level of specificity.\n                this.d(makeDepKey(dataId, fieldName));\n            }\n            if (this.parent) {\n                this.parent.depend(dataId, storeFieldName);\n            }\n        }\n    }\n    dirty(dataId, storeFieldName) {\n        if (this.d) {\n            this.d.dirty(makeDepKey(dataId, storeFieldName), \n            // When storeFieldName === \"__exists\", that means the entity identified\n            // by dataId has either disappeared from the cache or was newly added,\n            // so the result caching system would do well to \"forget everything it\n            // knows\" about that object. To achieve that kind of invalidation, we\n            // not only dirty the associated result cache entry, but also remove it\n            // completely from the dependency graph. For the optimism implementation\n            // details, see https://github.com/benjamn/optimism/pull/195.\n            storeFieldName === \"__exists\" ? \"forget\" : \"setDirty\");\n        }\n    }\n}\nfunction makeDepKey(dataId, storeFieldName) {\n    // Since field names cannot have '#' characters in them, this method\n    // of joining the field name and the ID should be unambiguous, and much\n    // cheaper than JSON.stringify([dataId, fieldName]).\n    return storeFieldName + \"#\" + dataId;\n}\nexport function maybeDependOnExistenceOfEntity(store, entityId) {\n    if (supportsResultCaching(store)) {\n        // We use this pseudo-field __exists elsewhere in the EntityStore code to\n        // represent changes in the existence of the entity object identified by\n        // entityId. This dependency gets reliably dirtied whenever an object with\n        // this ID is deleted (or newly created) within this group, so any result\n        // cache entries (for example, StoreReader#executeSelectionSet results) that\n        // depend on __exists for this entityId will get dirtied as well, leading to\n        // the eventual recomputation (instead of reuse) of those result objects the\n        // next time someone reads them from the cache.\n        store.group.depend(entityId, \"__exists\");\n    }\n}\nclass Root extends EntityStore {\n    constructor({ policies, resultCaching = true, seed, }) {\n        super(policies, new CacheGroup(resultCaching));\n        if (seed)\n            this.replace(seed);\n    }\n    stump = new Stump(this);\n    addLayer(layerId, replay) {\n        // Adding an optimistic Layer on top of the Root actually adds the Layer\n        // on top of the Stump, so the Stump always comes between the Root and\n        // any Layer objects that we've added.\n        return this.stump.addLayer(layerId, replay);\n    }\n    removeLayer() {\n        // Never remove the root layer.\n        return this;\n    }\n    storageTrie = new Trie();\n    getStorage() {\n        return this.storageTrie.lookupArray(arguments);\n    }\n}\nEntityStore.Root = Root;\n// Not exported, since all Layer instances are created by the addLayer method\n// of the EntityStore.Root class.\nclass Layer extends EntityStore {\n    id;\n    parent;\n    replay;\n    group;\n    constructor(id, parent, replay, group) {\n        super(parent.policies, group);\n        this.id = id;\n        this.parent = parent;\n        this.replay = replay;\n        this.group = group;\n        replay(this);\n    }\n    addLayer(layerId, replay) {\n        return new Layer(layerId, this, replay, this.group);\n    }\n    removeLayer(layerId) {\n        // Remove all instances of the given id, not just the first one.\n        const parent = this.parent.removeLayer(layerId);\n        if (layerId === this.id) {\n            if (this.group.caching) {\n                // Dirty every ID we're removing. Technically we might be able to avoid\n                // dirtying fields that have values in higher layers, but we don't have\n                // easy access to higher layers here, and we're about to recreate those\n                // layers anyway (see parent.addLayer below).\n                Object.keys(this.data).forEach((dataId) => {\n                    const ownStoreObject = this.data[dataId];\n                    const parentStoreObject = parent[\"lookup\"](dataId);\n                    if (!parentStoreObject) {\n                        // The StoreObject identified by dataId was defined in this layer\n                        // but will be undefined in the parent layer, so we can delete the\n                        // whole entity using this.delete(dataId). Since we're about to\n                        // throw this layer away, the only goal of this deletion is to dirty\n                        // the removed fields.\n                        this.delete(dataId);\n                    }\n                    else if (!ownStoreObject) {\n                        // This layer had an entry for dataId but it was undefined, which\n                        // means the entity was deleted in this layer, and it's about to\n                        // become undeleted when we remove this layer, so we need to dirty\n                        // all fields that are about to be reexposed.\n                        this.group.dirty(dataId, \"__exists\");\n                        Object.keys(parentStoreObject).forEach((storeFieldName) => {\n                            this.group.dirty(dataId, storeFieldName);\n                        });\n                    }\n                    else if (ownStoreObject !== parentStoreObject) {\n                        // If ownStoreObject is not exactly the same as parentStoreObject,\n                        // dirty any fields whose values will change as a result of this\n                        // removal.\n                        Object.keys(ownStoreObject).forEach((storeFieldName) => {\n                            if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {\n                                this.group.dirty(dataId, storeFieldName);\n                            }\n                        });\n                    }\n                });\n            }\n            return parent;\n        }\n        // No changes are necessary if the parent chain remains identical.\n        if (parent === this.parent)\n            return this;\n        // Recreate this layer on top of the new parent.\n        return parent.addLayer(this.id, this.replay);\n    }\n    toObject() {\n        return {\n            ...this.parent.toObject(),\n            ...this.data,\n        };\n    }\n    findChildRefIds(dataId) {\n        const fromParent = this.parent.findChildRefIds(dataId);\n        return hasOwn.call(this.data, dataId) ?\n            {\n                ...fromParent,\n                ...super.findChildRefIds(dataId),\n            }\n            : fromParent;\n    }\n    getStorage(...args) {\n        let p = this.parent;\n        while (p.parent)\n            p = p.parent;\n        return p.getStorage(...args);\n    }\n}\n// Represents a Layer permanently installed just above the Root, which allows\n// reading optimistically (and registering optimistic dependencies) even when\n// no optimistic layers are currently active. The stump.group CacheGroup object\n// is shared by any/all Layer objects added on top of the Stump.\nclass Stump extends Layer {\n    constructor(root) {\n        super(\"EntityStore.Stump\", root, () => { }, new CacheGroup(root.group.caching, root.group));\n    }\n    removeLayer() {\n        // Never remove the Stump layer.\n        return this;\n    }\n    merge(older, newer) {\n        // We never want to write any data into the Stump, so we forward any merge\n        // calls to the Root instead. Another option here would be to throw an\n        // exception, but the toReference(object, true) function can sometimes\n        // trigger Stump writes (which used to be Root writes, before the Stump\n        // concept was introduced).\n        return this.parent.merge(older, newer);\n    }\n}\nfunction storeObjectReconciler(existingObject, incomingObject, property) {\n    const existingValue = existingObject[property];\n    const incomingValue = incomingObject[property];\n    // Wherever there is a key collision, prefer the incoming value, unless\n    // it is deeply equal to the existing value. It's worth checking deep\n    // equality here (even though blindly returning incoming would be\n    // logically correct) because preserving the referential identity of\n    // existing data can prevent needless rereading and rerendering.\n    return equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\nexport function supportsResultCaching(store) {\n    // When result caching is disabled, store.depend will be null.\n    return !!(store && store.supportsResultCaching);\n}\n\n", "import { Kind } from \"graphql\";\nimport { Slot } from \"optimism\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n// Contextual slot that allows us to disable accessor warnings on fields when in\n// migrate mode.\n/**\n* @internal\n* \n* @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n*/\nexport const disableWarningsSlot = new Slot();\nexport function getFragmentMaskMode(fragment) {\n    const directive = fragment.directives?.find(({ name }) => name.value === \"unmask\");\n    if (!directive) {\n        return \"mask\";\n    }\n    const modeArg = directive.arguments?.find(({ name }) => name.value === \"mode\");\n    if (__DEV__) {\n        if (modeArg) {\n            if (modeArg.value.kind === Kind.VARIABLE) {\n                __DEV__ && invariant.warn(44);\n            }\n            else if (modeArg.value.kind !== Kind.STRING) {\n                __DEV__ && invariant.warn(45);\n            }\n            else if (modeArg.value.value !== \"migrate\") {\n                __DEV__ && invariant.warn(46, modeArg.value.value);\n            }\n        }\n    }\n    if (modeArg &&\n        \"value\" in modeArg.value &&\n        modeArg.value.value === \"migrate\") {\n        return \"migrate\";\n    }\n    return \"unmask\";\n}\n\n", "import { Kind } from \"graphql\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { maybeDeepFreeze, resultKeyNameFromField, } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { disableWarningsSlot, getFragmentMaskMode } from \"./utils.js\";\nexport function maskDefinition(data, selectionSet, context) {\n    return disableWarningsSlot.withValue(true, () => {\n        const masked = maskSelectionSet(data, selectionSet, context, false);\n        if (Object.isFrozen(data)) {\n            maybeDeepFreeze(masked);\n        }\n        return masked;\n    });\n}\nfunction getMutableTarget(data, mutableTargets) {\n    if (mutableTargets.has(data)) {\n        return mutableTargets.get(data);\n    }\n    const mutableTarget = Array.isArray(data) ? [] : {};\n    mutableTargets.set(data, mutableTarget);\n    return mutableTarget;\n}\nfunction maskSelectionSet(data, selectionSet, context, migration, path) {\n    const { knownChanged } = context;\n    const memo = getMutableTarget(data, context.mutableTargets);\n    if (Array.isArray(data)) {\n        for (const [index, item] of Array.from(data.entries())) {\n            if (item === null) {\n                memo[index] = null;\n                continue;\n            }\n            const masked = maskSelectionSet(item, selectionSet, context, migration, __DEV__ ? `${path || \"\"}[${index}]` : void 0);\n            if (knownChanged.has(masked)) {\n                knownChanged.add(memo);\n            }\n            memo[index] = masked;\n        }\n        return knownChanged.has(memo) ? memo : data;\n    }\n    for (const selection of selectionSet.selections) {\n        let value;\n        // we later want to add accessor warnings to the final result\n        // so we need a new object to add the accessor warning to\n        if (migration) {\n            knownChanged.add(memo);\n        }\n        if (selection.kind === Kind.FIELD) {\n            const keyName = resultKeyNameFromField(selection);\n            const childSelectionSet = selection.selectionSet;\n            value = memo[keyName] || data[keyName];\n            if (value === void 0) {\n                continue;\n            }\n            if (childSelectionSet && value !== null) {\n                const masked = maskSelectionSet(data[keyName], childSelectionSet, context, migration, __DEV__ ? `${path || \"\"}.${keyName}` : void 0);\n                if (knownChanged.has(masked)) {\n                    value = masked;\n                }\n            }\n            if (!__DEV__) {\n                memo[keyName] = value;\n            }\n            if (__DEV__) {\n                if (migration &&\n                    keyName !== \"__typename\" &&\n                    // either the field is not present in the memo object\n                    // or it has a `get` descriptor, not a `value` descriptor\n                    // => it is a warning accessor and we can overwrite it\n                    // with another accessor\n                    !Object.getOwnPropertyDescriptor(memo, keyName)?.value) {\n                    Object.defineProperty(memo, keyName, getAccessorWarningDescriptor(keyName, value, path || \"\", context.operationName, context.operationType));\n                }\n                else {\n                    delete memo[keyName];\n                    memo[keyName] = value;\n                }\n            }\n        }\n        if (selection.kind === Kind.INLINE_FRAGMENT &&\n            (!selection.typeCondition ||\n                context.cache.fragmentMatches(selection, data.__typename))) {\n            value = maskSelectionSet(data, selection.selectionSet, context, migration, path);\n        }\n        if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            const fragmentName = selection.name.value;\n            const fragment = context.fragmentMap[fragmentName] ||\n                (context.fragmentMap[fragmentName] =\n                    context.cache.lookupFragment(fragmentName));\n            invariant(fragment, 39, fragmentName);\n            const mode = getFragmentMaskMode(selection);\n            if (mode !== \"mask\") {\n                value = maskSelectionSet(data, fragment.selectionSet, context, mode === \"migrate\", path);\n            }\n        }\n        if (knownChanged.has(value)) {\n            knownChanged.add(memo);\n        }\n    }\n    if (\"__typename\" in data && !(\"__typename\" in memo)) {\n        memo.__typename = data.__typename;\n    }\n    // This check prevents cases where masked fields may accidentally be\n    // returned as part of this object when the fragment also selects\n    // additional fields from the same child selection.\n    if (Object.keys(memo).length !== Object.keys(data).length) {\n        knownChanged.add(memo);\n    }\n    return knownChanged.has(memo) ? memo : data;\n}\nfunction getAccessorWarningDescriptor(fieldName, value, path, operationName, operationType) {\n    let getValue = () => {\n        if (disableWarningsSlot.getValue()) {\n            return value;\n        }\n        __DEV__ && invariant.warn(40, operationName ?\n            `${operationType} '${operationName}'`\n            : `anonymous ${operationType}`, `${path}.${fieldName}`.replace(/^\\./, \"\"));\n        getValue = () => value;\n        return value;\n    };\n    return {\n        get() {\n            return getValue();\n        },\n        set(newValue) {\n            getValue = () => newValue;\n        },\n        enumerable: true,\n        configurable: true,\n    };\n}\n\n", "import { equal } from \"@wry/equality\";\nimport { Kind } from \"graphql\";\nimport { createFragmentMap, getFragmentDefinitions, } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { maskDefinition } from \"./maskDefinition.js\";\n/**\n* @internal\n* \n* @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n*/\nexport function maskFragment(data, document, cache, fragmentName) {\n    const fragments = document.definitions.filter((node) => node.kind === Kind.FRAGMENT_DEFINITION);\n    if (typeof fragmentName === \"undefined\") {\n        invariant(fragments.length === 1, 41, fragments.length);\n        fragmentName = fragments[0].name.value;\n    }\n    const fragment = fragments.find((fragment) => fragment.name.value === fragmentName);\n    invariant(!!fragment, 42, fragmentName);\n    if (data == null) {\n        // Maintain the original `null` or `undefined` value\n        return data;\n    }\n    if (equal(data, {})) {\n        // Return early and skip the masking algorithm if we don't have any data\n        // yet. This can happen when cache.diff returns an empty object which is\n        // used from watchFragment.\n        return data;\n    }\n    return maskDefinition(data, fragment.selectionSet, {\n        operationType: \"fragment\",\n        operationName: fragment.name.value,\n        fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n        cache,\n        mutableTargets: new WeakMap(),\n        knownChanged: new WeakSet(),\n    });\n}\n\n", "import { createFragmentMap, getFragmentDefinitions, getOperationDefinition, } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { maskDefinition } from \"./maskDefinition.js\";\n/**\n* @internal\n* \n* @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n*/\nexport function maskOperation(data, document, cache) {\n    const definition = getOperationDefinition(document);\n    invariant(definition, 43);\n    if (data == null) {\n        // Maintain the original `null` or `undefined` value\n        return data;\n    }\n    return maskDefinition(data, definition.selectionSet, {\n        operationType: definition.operation,\n        operationName: definition.name?.value,\n        fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n        cache,\n        mutableTargets: new WeakMap(),\n        knownChanged: new WeakSet(),\n    });\n}\n\n", "import { argumentsObjectFromField, DeepMerger, isArray, isNonEmptyArray, isNonNullObject, } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { hasOwn } from \"./helpers.js\";\n// Mapping from JSON-encoded KeySpecifier strings to associated information.\nconst specifierInfoCache = {};\nfunction lookupSpecifierInfo(spec) {\n    // It's safe to encode KeySpecifier arrays with JSON.stringify, since they're\n    // just arrays of strings or nested KeySpecifier arrays, and the order of the\n    // array elements is important (and suitably preserved by JSON.stringify).\n    const cacheKey = JSON.stringify(spec);\n    return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = {});\n}\nexport function keyFieldsFnFromSpecifier(specifier) {\n    const info = lookupSpecifierInfo(specifier);\n    return (info.keyFieldsFn || (info.keyFieldsFn = (object, context) => {\n            const extract = (from, key) => context.readField(key, from);\n            const keyObject = (context.keyObject = collectSpecifierPaths(specifier, (schemaKeyPath) => {\n                let extracted = extractKeyPath(context.storeObject, schemaKeyPath, \n                // Using context.readField to extract paths from context.storeObject\n                // allows the extraction to see through Reference objects and respect\n                // custom read functions.\n                extract);\n                if (extracted === void 0 &&\n                    object !== context.storeObject &&\n                    hasOwn.call(object, schemaKeyPath[0])) {\n                    // If context.storeObject fails to provide a value for the requested\n                    // path, fall back to the raw result object, if it has a top-level key\n                    // matching the first key in the path (schemaKeyPath[0]). This allows\n                    // key fields included in the written data to be saved in the cache\n                    // even if they are not selected explicitly in context.selectionSet.\n                    // Not being mentioned by context.selectionSet is convenient here,\n                    // since it means these extra fields cannot be affected by field\n                    // aliasing, which is why we can use extractKey instead of\n                    // context.readField for this extraction.\n                    extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n                }\n                invariant(extracted !== void 0, 99, schemaKeyPath.join(\".\"), object);\n                return extracted;\n            }));\n            return `${context.typename}:${JSON.stringify(keyObject)}`;\n        }));\n}\n// The keyArgs extraction process is roughly analogous to keyFields extraction,\n// but there are no aliases involved, missing fields are tolerated (by merely\n// omitting them from the key), and drawing from field.directives or variables\n// is allowed (in addition to drawing from the field's arguments object).\n// Concretely, these differences mean passing a different key path extractor\n// function to collectSpecifierPaths, reusing the shared extractKeyPath helper\n// wherever possible.\nexport function keyArgsFnFromSpecifier(specifier) {\n    const info = lookupSpecifierInfo(specifier);\n    return (info.keyArgsFn ||\n        (info.keyArgsFn = (args, { field, variables, fieldName }) => {\n            const collected = collectSpecifierPaths(specifier, (keyPath) => {\n                const firstKey = keyPath[0];\n                const firstChar = firstKey.charAt(0);\n                if (firstChar === \"@\") {\n                    if (field && isNonEmptyArray(field.directives)) {\n                        const directiveName = firstKey.slice(1);\n                        // If the directive appears multiple times, only the first\n                        // occurrence's arguments will be used. TODO Allow repetition?\n                        // TODO Cache this work somehow, a la aliasMap?\n                        const d = field.directives.find((d) => d.name.value === directiveName);\n                        // Fortunately argumentsObjectFromField works for DirectiveNode!\n                        const directiveArgs = d && argumentsObjectFromField(d, variables);\n                        // For directives without arguments (d defined, but directiveArgs ===\n                        // null), the presence or absence of the directive still counts as\n                        // part of the field key, so we return null in those cases. If no\n                        // directive with this name was found for this field (d undefined and\n                        // thus directiveArgs undefined), we return undefined, which causes\n                        // this value to be omitted from the key object returned by\n                        // collectSpecifierPaths.\n                        return (directiveArgs &&\n                            extractKeyPath(directiveArgs, \n                            // If keyPath.length === 1, this code calls extractKeyPath with an\n                            // empty path, which works because it uses directiveArgs as the\n                            // extracted value.\n                            keyPath.slice(1)));\n                    }\n                    // If the key started with @ but there was no corresponding directive,\n                    // we want to omit this value from the key object, not fall through to\n                    // treating @whatever as a normal argument name.\n                    return;\n                }\n                if (firstChar === \"$\") {\n                    const variableName = firstKey.slice(1);\n                    if (variables && hasOwn.call(variables, variableName)) {\n                        const varKeyPath = keyPath.slice(0);\n                        varKeyPath[0] = variableName;\n                        return extractKeyPath(variables, varKeyPath);\n                    }\n                    // If the key started with $ but there was no corresponding variable, we\n                    // want to omit this value from the key object, not fall through to\n                    // treating $whatever as a normal argument name.\n                    return;\n                }\n                if (args) {\n                    return extractKeyPath(args, keyPath);\n                }\n            });\n            const suffix = JSON.stringify(collected);\n            // If no arguments were passed to this field, and it didn't have any other\n            // field key contributions from directives or variables, hide the empty\n            // :{} suffix from the field key. However, a field passed no arguments can\n            // still end up with a non-empty :{...} suffix if its key configuration\n            // refers to directives or variables.\n            if (args || suffix !== \"{}\") {\n                fieldName += \":\" + suffix;\n            }\n            return fieldName;\n        }));\n}\nexport function collectSpecifierPaths(specifier, extractor) {\n    // For each path specified by specifier, invoke the extractor, and repeatedly\n    // merge the results together, with appropriate ancestor context.\n    const merger = new DeepMerger();\n    return getSpecifierPaths(specifier).reduce((collected, path) => {\n        let toMerge = extractor(path);\n        if (toMerge !== void 0) {\n            // This path is not expected to contain array indexes, so the toMerge\n            // reconstruction will not contain arrays. TODO Fix this?\n            for (let i = path.length - 1; i >= 0; --i) {\n                toMerge = { [path[i]]: toMerge };\n            }\n            collected = merger.merge(collected, toMerge);\n        }\n        return collected;\n    }, {});\n}\nexport function getSpecifierPaths(spec) {\n    const info = lookupSpecifierInfo(spec);\n    if (!info.paths) {\n        const paths = (info.paths = []);\n        const currentPath = [];\n        spec.forEach((s, i) => {\n            if (isArray(s)) {\n                getSpecifierPaths(s).forEach((p) => paths.push(currentPath.concat(p)));\n                currentPath.length = 0;\n            }\n            else {\n                currentPath.push(s);\n                if (!isArray(spec[i + 1])) {\n                    paths.push(currentPath.slice(0));\n                    currentPath.length = 0;\n                }\n            }\n        });\n    }\n    return info.paths;\n}\nfunction extractKey(object, key) {\n    return object[key];\n}\nexport function extractKeyPath(object, path, extract) {\n    // For each key in path, extract the corresponding child property from obj,\n    // flattening arrays if encountered (uncommon for keyFields and keyArgs, but\n    // possible). The final result of path.reduce is normalized so unexpected leaf\n    // objects have their keys safely sorted. That final result is difficult to\n    // type as anything other than any. You're welcome to try to improve the\n    // return type, but keep in mind extractKeyPath is not a public function\n    // (exported only for testing), so the effort may not be worthwhile unless the\n    // limited set of actual callers (see above) pass arguments that TypeScript\n    // can statically type. If we know only that path is some array of strings\n    // (and not, say, a specific tuple of statically known strings), any (or\n    // possibly unknown) is the honest answer.\n    extract = extract || extractKey;\n    return normalize(path.reduce(function reducer(obj, key) {\n        return isArray(obj) ?\n            obj.map((child) => reducer(child, key))\n            : obj && extract(obj, key);\n    }, object));\n}\nfunction normalize(value) {\n    // Usually the extracted value will be a scalar value, since most primary\n    // key fields are scalar, but just in case we get an object or an array, we\n    // need to do some normalization of the order of (nested) keys.\n    if (isNonNullObject(value)) {\n        if (isArray(value)) {\n            return value.map(normalize);\n        }\n        return collectSpecifierPaths(Object.keys(value).sort(), (path) => extractKeyPath(value, path));\n    }\n    return value;\n}\n\n", "import { dep, Slot } from \"optimism\";\n// Contextual Slot that acquires its value when custom read functions are\n// called in Policies#readField.\nexport const cacheSlot = new Slot();\nconst cacheInfoMap = new WeakMap();\nfunction getCacheInfo(cache) {\n    let info = cacheInfoMap.get(cache);\n    if (!info) {\n        cacheInfoMap.set(cache, (info = {\n            vars: new Set(),\n            dep: dep(),\n        }));\n    }\n    return info;\n}\nexport function forgetCache(cache) {\n    getCacheInfo(cache).vars.forEach((rv) => rv.forgetCache(cache));\n}\n// Calling forgetCache(cache) serves to silence broadcasts and allows the\n// cache to be garbage collected. However, the varsByCache WeakMap\n// preserves the set of reactive variables that were previously associated\n// with this cache, which makes it possible to \"recall\" the cache at a\n// later time, by reattaching it to those variables. If the cache has been\n// garbage collected in the meantime, because it is no longer reachable,\n// you won't be able to call recallCache(cache), and the cache will\n// automatically disappear from the varsByCache WeakMap.\nexport function recallCache(cache) {\n    getCacheInfo(cache).vars.forEach((rv) => rv.attachCache(cache));\n}\nexport function makeVar(value) {\n    const caches = new Set();\n    const listeners = new Set();\n    const rv = function (newValue) {\n        if (arguments.length > 0) {\n            if (value !== newValue) {\n                value = newValue;\n                caches.forEach((cache) => {\n                    // Invalidate any fields with custom read functions that\n                    // consumed this variable, so query results involving those\n                    // fields will be recomputed the next time we read them.\n                    getCacheInfo(cache).dep.dirty(rv);\n                    // Broadcast changes to any caches that have previously read\n                    // from this variable.\n                    broadcast(cache);\n                });\n                // Finally, notify any listeners added via rv.onNextChange.\n                const oldListeners = Array.from(listeners);\n                listeners.clear();\n                oldListeners.forEach((listener) => listener(value));\n            }\n        }\n        else {\n            // When reading from the variable, obtain the current cache from\n            // context via cacheSlot. This isn't entirely foolproof, but it's\n            // the same system that powers varDep.\n            const cache = cacheSlot.getValue();\n            if (cache) {\n                attach(cache);\n                getCacheInfo(cache).dep(rv);\n            }\n        }\n        return value;\n    };\n    rv.onNextChange = (listener) => {\n        listeners.add(listener);\n        return () => {\n            listeners.delete(listener);\n        };\n    };\n    const attach = (rv.attachCache = (cache) => {\n        caches.add(cache);\n        getCacheInfo(cache).vars.add(rv);\n        return rv;\n    });\n    rv.forgetCache = (cache) => caches.delete(cache);\n    return rv;\n}\nfunction broadcast(cache) {\n    if (cache.broadcastWatches) {\n        cache.broadcastWatches();\n    }\n}\n", "import { disableWarningsSlot } from \"@apollo/client/masking\";\nimport { isReference } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { argumentsObjectFromField, getStoreKeyName, isArray, isNonNullObject, storeKeyNameFromField, stringifyForDisplay, } from \"@apollo/client/utilities/internal\";\nimport { invariant, newInvariantError, } from \"@apollo/client/utilities/invariant\";\nimport { defaultDataIdFromObject, fieldNameFromStoreName, hasOwn, selectionSetMatchesResult, storeValueIsStoreObject, TypeOrFieldNameRegExp, } from \"./helpers.js\";\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier, } from \"./key-extractor.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nfunction argsFromFieldSpecifier(spec) {\n    return (spec.args !== void 0 ? spec.args\n        : spec.field ? argumentsObjectFromField(spec.field, spec.variables)\n            : null);\n}\nconst nullKeyFieldsFn = () => void 0;\nconst simpleKeyArgsFn = (_args, context) => context.fieldName;\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nconst mergeTrueFn = (existing, incoming, { mergeObjects }) => mergeObjects(existing, incoming);\nconst mergeFalseFn = (_, incoming) => incoming;\nexport class Policies {\n    config;\n    typePolicies = {};\n    toBeAdded = {};\n    // Map from subtype names to sets of supertype names. Note that this\n    // representation inverts the structure of possibleTypes (whose keys are\n    // supertypes and whose values are arrays of subtypes) because it tends\n    // to be much more efficient to search upwards than downwards.\n    supertypeMap = new Map();\n    // Any fuzzy subtypes specified by possibleTypes will be converted to\n    // RegExp objects and recorded here. Every key of this map can also be\n    // found in supertypeMap. In many cases this Map will be empty, which\n    // means no fuzzy subtype checking will happen in fragmentMatches.\n    fuzzySubtypes = new Map();\n    cache;\n    rootIdsByTypename = {};\n    rootTypenamesById = {};\n    usingPossibleTypes = false;\n    constructor(config) {\n        this.config = config;\n        this.config = {\n            dataIdFromObject: defaultDataIdFromObject,\n            ...config,\n        };\n        this.cache = this.config.cache;\n        this.setRootTypename(\"Query\");\n        this.setRootTypename(\"Mutation\");\n        this.setRootTypename(\"Subscription\");\n        if (config.possibleTypes) {\n            this.addPossibleTypes(config.possibleTypes);\n        }\n        if (config.typePolicies) {\n            this.addTypePolicies(config.typePolicies);\n        }\n    }\n    identify(object, partialContext) {\n        const policies = this;\n        const typename = (partialContext &&\n            (partialContext.typename || partialContext.storeObject?.__typename)) ||\n            object.__typename;\n        // It should be possible to write root Query fields with writeFragment,\n        // using { __typename: \"Query\", ... } as the data, but it does not make\n        // sense to allow the same identification behavior for the Mutation and\n        // Subscription types, since application code should never be writing\n        // directly to (or reading directly from) those root objects.\n        if (typename === this.rootTypenamesById.ROOT_QUERY) {\n            return [\"ROOT_QUERY\"];\n        }\n        // Default context.storeObject to object if not otherwise provided.\n        const storeObject = (partialContext && partialContext.storeObject) || object;\n        const context = {\n            ...partialContext,\n            typename,\n            storeObject,\n            readField: (partialContext && partialContext.readField) ||\n                ((...args) => {\n                    const options = normalizeReadFieldOptions(args, storeObject);\n                    return policies.readField(options, {\n                        store: policies.cache[\"data\"],\n                        variables: options.variables,\n                    });\n                }),\n        };\n        let id;\n        const policy = typename && this.getTypePolicy(typename);\n        let keyFn = (policy && policy.keyFn) || this.config.dataIdFromObject;\n        disableWarningsSlot.withValue(true, () => {\n            while (keyFn) {\n                const specifierOrId = keyFn({ ...object, ...storeObject }, context);\n                if (isArray(specifierOrId)) {\n                    keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n                }\n                else {\n                    id = specifierOrId;\n                    break;\n                }\n            }\n        });\n        id = id ? String(id) : void 0;\n        return context.keyObject ? [id, context.keyObject] : [id];\n    }\n    addTypePolicies(typePolicies) {\n        Object.keys(typePolicies).forEach((typename) => {\n            const { queryType, mutationType, subscriptionType, ...incoming } = typePolicies[typename];\n            // Though {query,mutation,subscription}Type configurations are rare,\n            // it's important to call setRootTypename as early as possible,\n            // since these configurations should apply consistently for the\n            // entire lifetime of the cache. Also, since only one __typename can\n            // qualify as one of these root types, these three properties cannot\n            // be inherited, unlike the rest of the incoming properties. That\n            // restriction is convenient, because the purpose of this.toBeAdded\n            // is to delay the processing of type/field policies until the first\n            // time they're used, allowing policies to be added in any order as\n            // long as all relevant policies (including policies for supertypes)\n            // have been added by the time a given policy is used for the first\n            // time. In other words, since inheritance doesn't matter for these\n            // properties, there's also no need to delay their processing using\n            // the this.toBeAdded queue.\n            if (queryType)\n                this.setRootTypename(\"Query\", typename);\n            if (mutationType)\n                this.setRootTypename(\"Mutation\", typename);\n            if (subscriptionType)\n                this.setRootTypename(\"Subscription\", typename);\n            if (hasOwn.call(this.toBeAdded, typename)) {\n                this.toBeAdded[typename].push(incoming);\n            }\n            else {\n                this.toBeAdded[typename] = [incoming];\n            }\n        });\n    }\n    updateTypePolicy(typename, incoming, existingFieldPolicies) {\n        const existing = this.getTypePolicy(typename);\n        const { keyFields, fields } = incoming;\n        function setMerge(existing, merge) {\n            existing.merge =\n                typeof merge === \"function\" ? merge\n                    // Pass merge:true as a shorthand for a merge implementation\n                    // that returns options.mergeObjects(existing, incoming).\n                    : merge === true ? mergeTrueFn\n                        // Pass merge:false to make incoming always replace existing\n                        // without any warnings about data clobbering.\n                        : merge === false ? mergeFalseFn\n                            : existing.merge;\n        }\n        // Type policies can define merge functions, as an alternative to\n        // using field policies to merge child objects.\n        setMerge(existing, incoming.merge);\n        existing.keyFn =\n            // Pass false to disable normalization for this typename.\n            keyFields === false ? nullKeyFieldsFn\n                // Pass an array of strings to use those fields to compute a\n                // composite ID for objects of this typename.\n                : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields)\n                    // Pass a function to take full control over identification.\n                    : typeof keyFields === \"function\" ? keyFields\n                        // Leave existing.keyFn unchanged if above cases fail.\n                        : existing.keyFn;\n        if (fields) {\n            Object.keys(fields).forEach((fieldName) => {\n                let existing = existingFieldPolicies[fieldName];\n                // Field policy inheritance is atomic/shallow: you can't inherit a\n                // field policy and then override just its read function, since read\n                // and merge functions often need to cooperate, so changing only one\n                // of them would be a recipe for inconsistency.\n                // So here we avoid merging an inherited field policy with an updated one.\n                if (!existing || existing?.typename !== typename) {\n                    existing = existingFieldPolicies[fieldName] = { typename };\n                }\n                const incoming = fields[fieldName];\n                if (typeof incoming === \"function\") {\n                    existing.read = incoming;\n                }\n                else {\n                    const { keyArgs, read, merge } = incoming;\n                    existing.keyFn =\n                        // Pass false to disable argument-based differentiation of\n                        // field identities.\n                        keyArgs === false ? simpleKeyArgsFn\n                            // Pass an array of strings to use named arguments to\n                            // compute a composite identity for the field.\n                            : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs)\n                                // Pass a function to take full control over field identity.\n                                : typeof keyArgs === \"function\" ? keyArgs\n                                    // Leave existing.keyFn unchanged if above cases fail.\n                                    : existing.keyFn;\n                    if (typeof read === \"function\") {\n                        existing.read = read;\n                    }\n                    setMerge(existing, merge);\n                }\n                if (existing.read && existing.merge) {\n                    // If we have both a read and a merge function, assume\n                    // keyArgs:false, because read and merge together can take\n                    // responsibility for interpreting arguments in and out. This\n                    // default assumption can always be overridden by specifying\n                    // keyArgs explicitly in the FieldPolicy.\n                    existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n                }\n            });\n        }\n    }\n    setRootTypename(which, typename = which) {\n        const rootId = \"ROOT_\" + which.toUpperCase();\n        const old = this.rootTypenamesById[rootId];\n        if (typename !== old) {\n            invariant(!old || old === which, 100, which);\n            // First, delete any old __typename associated with this rootId from\n            // rootIdsByTypename.\n            if (old)\n                delete this.rootIdsByTypename[old];\n            // Now make this the only __typename that maps to this rootId.\n            this.rootIdsByTypename[typename] = rootId;\n            // Finally, update the __typename associated with this rootId.\n            this.rootTypenamesById[rootId] = typename;\n        }\n    }\n    addPossibleTypes(possibleTypes) {\n        this.usingPossibleTypes = true;\n        Object.keys(possibleTypes).forEach((supertype) => {\n            // Make sure all types have an entry in this.supertypeMap, even if\n            // their supertype set is empty, so we can return false immediately\n            // from policies.fragmentMatches for unknown supertypes.\n            this.getSupertypeSet(supertype, true);\n            possibleTypes[supertype].forEach((subtype) => {\n                this.getSupertypeSet(subtype, true).add(supertype);\n                const match = subtype.match(TypeOrFieldNameRegExp);\n                if (!match || match[0] !== subtype) {\n                    // TODO Don't interpret just any invalid typename as a RegExp.\n                    this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n                }\n            });\n        });\n    }\n    getTypePolicy(typename) {\n        if (!hasOwn.call(this.typePolicies, typename)) {\n            const policy = (this.typePolicies[typename] = {});\n            policy.fields = {};\n            // When the TypePolicy for typename is first accessed, instead of\n            // starting with an empty policy object, inherit any properties or\n            // fields from the type policies of the supertypes of typename.\n            //\n            // Any properties or fields defined explicitly within the TypePolicy\n            // for typename will take precedence, and if there are multiple\n            // supertypes, the properties of policies whose types were added\n            // later via addPossibleTypes will take precedence over those of\n            // earlier supertypes. TODO Perhaps we should warn about these\n            // conflicts in development, and recommend defining the property\n            // explicitly in the subtype policy?\n            //\n            // Field policy inheritance is atomic/shallow: you can't inherit a\n            // field policy and then override just its read function, since read\n            // and merge functions often need to cooperate, so changing only one\n            // of them would be a recipe for inconsistency.\n            //\n            // Once the TypePolicy for typename has been accessed, its properties can\n            // still be updated directly using addTypePolicies, but future changes to\n            // inherited supertype policies will not be reflected in this subtype\n            // policy, because this code runs at most once per typename.\n            let supertypes = this.supertypeMap.get(typename);\n            if (!supertypes && this.fuzzySubtypes.size) {\n                // To make the inheritance logic work for unknown typename strings that\n                // may have fuzzy supertypes, we give this typename an empty supertype\n                // set and then populate it with any fuzzy supertypes that match.\n                supertypes = this.getSupertypeSet(typename, true);\n                // This only works for typenames that are directly matched by a fuzzy\n                // supertype. What if there is an intermediate chain of supertypes?\n                // While possible, that situation can only be solved effectively by\n                // specifying the intermediate relationships via possibleTypes, manually\n                // and in a non-fuzzy way.\n                this.fuzzySubtypes.forEach((regExp, fuzzy) => {\n                    if (regExp.test(typename)) {\n                        // The fuzzy parameter is just the original string version of regExp\n                        // (not a valid __typename string), but we can look up the\n                        // associated supertype(s) in this.supertypeMap.\n                        const fuzzySupertypes = this.supertypeMap.get(fuzzy);\n                        if (fuzzySupertypes) {\n                            fuzzySupertypes.forEach((supertype) => supertypes.add(supertype));\n                        }\n                    }\n                });\n            }\n            if (supertypes && supertypes.size) {\n                supertypes.forEach((supertype) => {\n                    const { fields, ...rest } = this.getTypePolicy(supertype);\n                    Object.assign(policy, rest);\n                    Object.assign(policy.fields, fields);\n                });\n            }\n        }\n        const inbox = this.toBeAdded[typename];\n        if (inbox && inbox.length) {\n            // Merge the pending policies into this.typePolicies, in the order they\n            // were originally passed to addTypePolicy.\n            inbox.splice(0).forEach((policy) => {\n                this.updateTypePolicy(typename, policy, this.typePolicies[typename].fields);\n            });\n        }\n        return this.typePolicies[typename];\n    }\n    getFieldPolicy(typename, fieldName) {\n        if (typename) {\n            return this.getTypePolicy(typename).fields[fieldName];\n        }\n    }\n    getSupertypeSet(subtype, createIfMissing) {\n        let supertypeSet = this.supertypeMap.get(subtype);\n        if (!supertypeSet && createIfMissing) {\n            this.supertypeMap.set(subtype, (supertypeSet = new Set()));\n        }\n        return supertypeSet;\n    }\n    fragmentMatches(fragment, typename, result, variables) {\n        if (!fragment.typeCondition)\n            return true;\n        // If the fragment has a type condition but the object we're matching\n        // against does not have a __typename, the fragment cannot match.\n        if (!typename)\n            return false;\n        const supertype = fragment.typeCondition.name.value;\n        // Common case: fragment type condition and __typename are the same.\n        if (typename === supertype)\n            return true;\n        if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n            const typenameSupertypeSet = this.getSupertypeSet(typename, true);\n            const workQueue = [typenameSupertypeSet];\n            const maybeEnqueue = (subtype) => {\n                const supertypeSet = this.getSupertypeSet(subtype, false);\n                if (supertypeSet &&\n                    supertypeSet.size &&\n                    workQueue.indexOf(supertypeSet) < 0) {\n                    workQueue.push(supertypeSet);\n                }\n            };\n            // We need to check fuzzy subtypes only if we encountered fuzzy\n            // subtype strings in addPossibleTypes, and only while writing to\n            // the cache, since that's when selectionSetMatchesResult gives a\n            // strong signal of fragment matching. The StoreReader class calls\n            // policies.fragmentMatches without passing a result object, so\n            // needToCheckFuzzySubtypes is always false while reading.\n            let needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n            let checkingFuzzySubtypes = false;\n            // It's important to keep evaluating workQueue.length each time through\n            // the loop, because the queue can grow while we're iterating over it.\n            for (let i = 0; i < workQueue.length; ++i) {\n                const supertypeSet = workQueue[i];\n                if (supertypeSet.has(supertype)) {\n                    if (!typenameSupertypeSet.has(supertype)) {\n                        if (checkingFuzzySubtypes) {\n                            __DEV__ && invariant.warn(101, typename, supertype);\n                        }\n                        // Record positive results for faster future lookup.\n                        // Unfortunately, we cannot safely cache negative results,\n                        // because new possibleTypes data could always be added to the\n                        // Policies class.\n                        typenameSupertypeSet.add(supertype);\n                    }\n                    return true;\n                }\n                supertypeSet.forEach(maybeEnqueue);\n                if (needToCheckFuzzySubtypes &&\n                    // Start checking fuzzy subtypes only after exhausting all\n                    // non-fuzzy subtypes (after the final iteration of the loop).\n                    i === workQueue.length - 1 &&\n                    // We could wait to compare fragment.selectionSet to result\n                    // after we verify the supertype, but this check is often less\n                    // expensive than that search, and we will have to do the\n                    // comparison anyway whenever we find a potential match.\n                    selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n                    // We don't always need to check fuzzy subtypes (if no result\n                    // was provided, or !this.fuzzySubtypes.size), but, when we do,\n                    // we only want to check them once.\n                    needToCheckFuzzySubtypes = false;\n                    checkingFuzzySubtypes = true;\n                    // If we find any fuzzy subtypes that match typename, extend the\n                    // workQueue to search through the supertypes of those fuzzy\n                    // subtypes. Otherwise the for-loop will terminate and we'll\n                    // return false below.\n                    this.fuzzySubtypes.forEach((regExp, fuzzyString) => {\n                        const match = typename.match(regExp);\n                        if (match && match[0] === typename) {\n                            maybeEnqueue(fuzzyString);\n                        }\n                    });\n                }\n            }\n        }\n        return false;\n    }\n    hasKeyArgs(typename, fieldName) {\n        const policy = this.getFieldPolicy(typename, fieldName);\n        return !!(policy && policy.keyFn);\n    }\n    getStoreFieldName(fieldSpec) {\n        const { typename, fieldName } = fieldSpec;\n        const policy = this.getFieldPolicy(typename, fieldName);\n        let storeFieldName;\n        let keyFn = policy && policy.keyFn;\n        if (keyFn && typename) {\n            const context = {\n                typename,\n                fieldName,\n                field: fieldSpec.field || null,\n                variables: fieldSpec.variables,\n            };\n            const args = argsFromFieldSpecifier(fieldSpec);\n            while (keyFn) {\n                const specifierOrString = keyFn(args, context);\n                if (isArray(specifierOrString)) {\n                    keyFn = keyArgsFnFromSpecifier(specifierOrString);\n                }\n                else {\n                    // If the custom keyFn returns a falsy value, fall back to\n                    // fieldName instead.\n                    storeFieldName = specifierOrString || fieldName;\n                    break;\n                }\n            }\n        }\n        if (storeFieldName === void 0) {\n            storeFieldName =\n                fieldSpec.field ?\n                    storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n                    : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n        }\n        // Returning false from a keyArgs function is like configuring\n        // keyArgs: false, but more dynamic.\n        if (storeFieldName === false) {\n            return fieldName;\n        }\n        // Make sure custom field names start with the actual field.name.value\n        // of the field, so we can always figure out which properties of a\n        // StoreObject correspond to which original field names.\n        return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName\n            : fieldName + \":\" + storeFieldName;\n    }\n    readField(options, context) {\n        const objectOrReference = options.from;\n        if (!objectOrReference)\n            return;\n        const nameOrField = options.field || options.fieldName;\n        if (!nameOrField)\n            return;\n        if (options.typename === void 0) {\n            const typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n            if (typename)\n                options.typename = typename;\n        }\n        const storeFieldName = this.getStoreFieldName(options);\n        const fieldName = fieldNameFromStoreName(storeFieldName);\n        const existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n        const policy = this.getFieldPolicy(options.typename, fieldName);\n        const read = policy && policy.read;\n        if (read) {\n            const readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ?\n                objectOrReference.__ref\n                : objectOrReference, storeFieldName));\n            // Call read(existing, readOptions) with cacheSlot holding this.cache.\n            return cacheSlot.withValue(this.cache, read, [\n                existing,\n                readOptions,\n            ]);\n        }\n        return existing;\n    }\n    getReadFunction(typename, fieldName) {\n        const policy = this.getFieldPolicy(typename, fieldName);\n        return policy && policy.read;\n    }\n    getMergeFunction(parentTypename, fieldName, childTypename) {\n        let policy = this.getFieldPolicy(parentTypename, fieldName);\n        let merge = policy && policy.merge;\n        if (!merge && childTypename) {\n            policy = this.getTypePolicy(childTypename);\n            merge = policy && policy.merge;\n        }\n        return merge;\n    }\n    runMergeFunction(existing, incoming, { field, typename, merge }, context, storage) {\n        if (merge === mergeTrueFn) {\n            // Instead of going to the trouble of creating a full\n            // FieldFunctionOptions object and calling mergeTrueFn, we can\n            // simply call mergeObjects, as mergeTrueFn would.\n            return makeMergeObjectsFunction(context.store)(existing, incoming);\n        }\n        if (merge === mergeFalseFn) {\n            // Likewise for mergeFalseFn, whose implementation is even simpler.\n            return incoming;\n        }\n        // If cache.writeQuery or cache.writeFragment was called with\n        // options.overwrite set to true, we still call merge functions, but\n        // the existing data is always undefined, so the merge function will\n        // not attempt to combine the incoming data with the existing data.\n        if (context.overwrite) {\n            existing = void 0;\n        }\n        return merge(existing, incoming, makeFieldFunctionOptions(this, \n        // Unlike options.readField for read functions, we do not fall\n        // back to the current object if no foreignObjOrRef is provided,\n        // because it's not clear what the current object should be for\n        // merge functions: the (possibly undefined) existing object, or\n        // the incoming object? If you think your merge function needs\n        // to read sibling fields in order to produce a new value for\n        // the current field, you might want to rethink your strategy,\n        // because that's a recipe for making merge behavior sensitive\n        // to the order in which fields are written into the cache.\n        // However, readField(name, ref) is useful for merge functions\n        // that need to deduplicate child objects and references.\n        void 0, {\n            typename,\n            fieldName: field.name.value,\n            field,\n            variables: context.variables,\n        }, context, storage || {}));\n    }\n}\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n    const storeFieldName = policies.getStoreFieldName(fieldSpec);\n    const fieldName = fieldNameFromStoreName(storeFieldName);\n    const variables = fieldSpec.variables || context.variables;\n    const { toReference, canRead } = context.store;\n    return {\n        args: argsFromFieldSpecifier(fieldSpec),\n        field: fieldSpec.field || null,\n        fieldName,\n        storeFieldName,\n        variables,\n        isReference,\n        toReference,\n        storage,\n        cache: policies.cache,\n        canRead,\n        readField(...args) {\n            return policies.readField(normalizeReadFieldOptions(args, objectOrReference, variables), context);\n        },\n        mergeObjects: makeMergeObjectsFunction(context.store),\n    };\n}\nexport function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n    const { 0: fieldNameOrOptions, 1: from, length: argc } = readFieldArgs;\n    let options;\n    if (typeof fieldNameOrOptions === \"string\") {\n        options = {\n            fieldName: fieldNameOrOptions,\n            // Default to objectOrReference only when no second argument was\n            // passed for the from parameter, not when undefined is explicitly\n            // passed as the second argument.\n            from: argc > 1 ? from : objectOrReference,\n        };\n    }\n    else {\n        options = { ...fieldNameOrOptions };\n        // Default to objectOrReference only when fieldNameOrOptions.from is\n        // actually omitted, rather than just undefined.\n        if (!hasOwn.call(options, \"from\")) {\n            options.from = objectOrReference;\n        }\n    }\n    if (__DEV__ && options.from === void 0) {\n        __DEV__ && invariant.warn(102, stringifyForDisplay(Array.from(readFieldArgs)));\n    }\n    if (void 0 === options.variables) {\n        options.variables = variables;\n    }\n    return options;\n}\nfunction makeMergeObjectsFunction(store) {\n    return function mergeObjects(existing, incoming) {\n        if (isArray(existing) || isArray(incoming)) {\n            throw newInvariantError(103);\n        }\n        // These dynamic checks are necessary because the parameters of a\n        // custom merge function can easily have the any type, so the type\n        // system cannot always enforce the StoreObject | Reference parameter\n        // types of options.mergeObjects.\n        if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n            const eType = store.getFieldValue(existing, \"__typename\");\n            const iType = store.getFieldValue(incoming, \"__typename\");\n            const typesDiffer = eType && iType && eType !== iType;\n            if (typesDiffer) {\n                return incoming;\n            }\n            if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n                // Update the normalized EntityStore for the entity identified by\n                // existing.__ref, preferring/overwriting any fields contributed by the\n                // newer incoming StoreObject.\n                store.merge(existing.__ref, incoming);\n                return existing;\n            }\n            if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n                // Update the normalized EntityStore for the entity identified by\n                // incoming.__ref, taking fields from the older existing object only if\n                // those fields are not already present in the newer StoreObject\n                // identified by incoming.__ref.\n                store.merge(existing, incoming.__ref);\n                return incoming;\n            }\n            if (storeValueIsStoreObject(existing) &&\n                storeValueIsStoreObject(incoming)) {\n                return { ...existing, ...incoming };\n            }\n        }\n        return incoming;\n    };\n}\n\n", "import { Kind } from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { addTypenameToDocument, cacheSizes, canonicalStringify, isReference, } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { DeepMerger, getDefaultValues, getFragmentFromSelection, getMainDefinition, getQueryDefinition, isArray, isField, isNonNullObject, makeReference, maybeDeepFreeze, mergeDeepArray, resultKeyNameFromField, shouldInclude, } from \"@apollo/client/utilities/internal\";\nimport { invariant, newInvariantError, } from \"@apollo/client/utilities/invariant\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching, } from \"./entityStore.js\";\nimport { extractFragmentContext, getTypenameFromStoreObject, } from \"./helpers.js\";\nfunction execSelectionSetKeyArgs(options) {\n    return [options.selectionSet, options.objectOrReference, options.context];\n}\nexport class StoreReader {\n    // cached version of executeSelectionSet\n    executeSelectionSet;\n    // cached version of executeSubSelectedArray\n    executeSubSelectedArray;\n    config;\n    knownResults = new WeakMap();\n    constructor(config) {\n        this.config = config;\n        // memoized functions in this class will be \"garbage-collected\"\n        // by recreating the whole `StoreReader` in\n        // `InMemoryCache.resetResultsCache`\n        // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\n        this.executeSelectionSet = wrap((options) => {\n            const peekArgs = execSelectionSetKeyArgs(options);\n            const other = this.executeSelectionSet.peek(...peekArgs);\n            if (other) {\n                // If we previously read this result with canonization enabled, we can\n                // return that canonized result as-is.\n                return other;\n            }\n            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n            // Finally, if we didn't find any useful previous results, run the real\n            // execSelectionSetImpl method with the given options.\n            return this.execSelectionSetImpl(options);\n        }, {\n            max: cacheSizes[\"inMemoryCache.executeSelectionSet\"] ||\n                50000 /* defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"] */,\n            keyArgs: execSelectionSetKeyArgs,\n            // Note that the parameters of makeCacheKey are determined by the\n            // array returned by keyArgs.\n            makeCacheKey(selectionSet, parent, context) {\n                if (supportsResultCaching(context.store)) {\n                    return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString);\n                }\n            },\n        });\n        this.executeSubSelectedArray = wrap((options) => {\n            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n            return this.execSubSelectedArrayImpl(options);\n        }, {\n            max: cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] ||\n                10000 /* defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"] */,\n            makeCacheKey({ field, array, context }) {\n                if (supportsResultCaching(context.store)) {\n                    return context.store.makeCacheKey(field, array, context.varString);\n                }\n            },\n        });\n    }\n    /**\n     * Given a store and a query, return as much of the result as possible and\n     * identify if any data was missing from the store.\n     */\n    diffQueryAgainstStore({ store, query, rootId = \"ROOT_QUERY\", variables, returnPartialData = true, }) {\n        const policies = this.config.cache.policies;\n        variables = {\n            ...getDefaultValues(getQueryDefinition(query)),\n            ...variables,\n        };\n        const rootRef = makeReference(rootId);\n        const execResult = this.executeSelectionSet({\n            selectionSet: getMainDefinition(query).selectionSet,\n            objectOrReference: rootRef,\n            enclosingRef: rootRef,\n            context: {\n                store,\n                query,\n                policies,\n                variables,\n                varString: canonicalStringify(variables),\n                ...extractFragmentContext(query, this.config.fragments),\n            },\n        });\n        let missing;\n        if (execResult.missing) {\n            missing = new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables);\n        }\n        const complete = !missing;\n        const { result } = execResult;\n        return {\n            result: complete || returnPartialData ?\n                Object.keys(result).length === 0 ?\n                    null\n                    : result\n                : null,\n            complete,\n            missing,\n        };\n    }\n    isFresh(result, parent, selectionSet, context) {\n        if (supportsResultCaching(context.store) &&\n            this.knownResults.get(result) === selectionSet) {\n            const latest = this.executeSelectionSet.peek(selectionSet, parent, context);\n            if (latest && result === latest.result) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // Uncached version of executeSelectionSet.\n    execSelectionSetImpl({ selectionSet, objectOrReference, enclosingRef, context, }) {\n        if (isReference(objectOrReference) &&\n            !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n            !context.store.has(objectOrReference.__ref)) {\n            return {\n                result: {},\n                missing: `Dangling reference to missing ${objectOrReference.__ref} object`,\n            };\n        }\n        const { variables, policies, store } = context;\n        const typename = store.getFieldValue(objectOrReference, \"__typename\");\n        const objectsToMerge = [];\n        let missing;\n        const missingMerger = new DeepMerger();\n        if (typeof typename === \"string\" && !policies.rootIdsByTypename[typename]) {\n            // Ensure we always include a default value for the __typename\n            // field, if we have one. Note that this field can be overridden by other\n            // merged objects.\n            objectsToMerge.push({ __typename: typename });\n        }\n        function handleMissing(result, resultName) {\n            if (result.missing) {\n                missing = missingMerger.merge(missing, {\n                    [resultName]: result.missing,\n                });\n            }\n            return result.result;\n        }\n        const workSet = new Set(selectionSet.selections);\n        workSet.forEach((selection) => {\n            // Omit fields with directives @skip(if: <truthy value>) or\n            // @include(if: <falsy value>).\n            if (!shouldInclude(selection, variables))\n                return;\n            if (isField(selection)) {\n                let fieldValue = policies.readField({\n                    fieldName: selection.name.value,\n                    field: selection,\n                    variables: context.variables,\n                    from: objectOrReference,\n                }, context);\n                const resultName = resultKeyNameFromField(selection);\n                if (fieldValue === void 0) {\n                    if (!addTypenameToDocument.added(selection)) {\n                        missing = missingMerger.merge(missing, {\n                            [resultName]: `Can't find field '${selection.name.value}' on ${isReference(objectOrReference) ?\n                                objectOrReference.__ref + \" object\"\n                                : \"object \" + JSON.stringify(objectOrReference, null, 2)}`,\n                        });\n                    }\n                }\n                else if (isArray(fieldValue)) {\n                    if (fieldValue.length > 0) {\n                        fieldValue = handleMissing(this.executeSubSelectedArray({\n                            field: selection,\n                            array: fieldValue,\n                            enclosingRef,\n                            context,\n                        }), resultName);\n                    }\n                }\n                else if (!selection.selectionSet) {\n                    // do nothing\n                }\n                else if (fieldValue != null) {\n                    // In this case, because we know the field has a selection set,\n                    // it must be trying to query a GraphQLObjectType, which is why\n                    // fieldValue must be != null.\n                    fieldValue = handleMissing(this.executeSelectionSet({\n                        selectionSet: selection.selectionSet,\n                        objectOrReference: fieldValue,\n                        enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n                        context,\n                    }), resultName);\n                }\n                if (fieldValue !== void 0) {\n                    objectsToMerge.push({ [resultName]: fieldValue });\n                }\n            }\n            else {\n                const fragment = getFragmentFromSelection(selection, context.lookupFragment);\n                if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n                    throw newInvariantError(104, selection.name.value);\n                }\n                if (fragment && policies.fragmentMatches(fragment, typename)) {\n                    fragment.selectionSet.selections.forEach(workSet.add, workSet);\n                }\n            }\n        });\n        const result = mergeDeepArray(objectsToMerge);\n        const finalResult = { result, missing };\n        const frozen = maybeDeepFreeze(finalResult);\n        // Store this result with its selection set so that we can quickly\n        // recognize it again in the StoreReader#isFresh method.\n        if (frozen.result) {\n            this.knownResults.set(frozen.result, selectionSet);\n        }\n        return frozen;\n    }\n    // Uncached version of executeSubSelectedArray.\n    execSubSelectedArrayImpl({ field, array, enclosingRef, context, }) {\n        let missing;\n        let missingMerger = new DeepMerger();\n        function handleMissing(childResult, i) {\n            if (childResult.missing) {\n                missing = missingMerger.merge(missing, { [i]: childResult.missing });\n            }\n            return childResult.result;\n        }\n        if (field.selectionSet) {\n            array = array.filter(context.store.canRead);\n        }\n        array = array.map((item, i) => {\n            // null value in array\n            if (item === null) {\n                return null;\n            }\n            // This is a nested array, recurse\n            if (isArray(item)) {\n                return handleMissing(this.executeSubSelectedArray({\n                    field,\n                    array: item,\n                    enclosingRef,\n                    context,\n                }), i);\n            }\n            // This is an object, run the selection set on it\n            if (field.selectionSet) {\n                return handleMissing(this.executeSelectionSet({\n                    selectionSet: field.selectionSet,\n                    objectOrReference: item,\n                    enclosingRef: isReference(item) ? item : enclosingRef,\n                    context,\n                }), i);\n            }\n            if (__DEV__) {\n                assertSelectionSetForIdValue(context.store, field, item);\n            }\n            return item;\n        });\n        return {\n            result: array,\n            missing,\n        };\n    }\n}\nfunction firstMissing(tree) {\n    try {\n        JSON.stringify(tree, (_, value) => {\n            if (typeof value === \"string\")\n                throw value;\n            return value;\n        });\n    }\n    catch (result) {\n        return result;\n    }\n}\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n    if (!field.selectionSet) {\n        const workSet = new Set([fieldValue]);\n        workSet.forEach((value) => {\n            if (isNonNullObject(value)) {\n                invariant(\n                    !isReference(value),\n                    105,\n                    getTypenameFromStoreObject(store, value),\n                    field.name.value\n                );\n                Object.values(value).forEach(workSet.add, workSet);\n            }\n        });\n    }\n}\n\n", "import { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport { Kind } from \"graphql\";\nimport { addTypenameToDocument, canonicalStringify, isReference, } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { argumentsObjectFromField, cloneDeep, getDefaultValues, getFragmentFromSelection, getOperationDefinition, isArray, isField, isNonEmptyArray, makeReference, resultKeyNameFromField, shouldInclude, } from \"@apollo/client/utilities/internal\";\nimport { invariant, newInvariantError, } from \"@apollo/client/utilities/invariant\";\nimport { extractFragmentContext, fieldNameFromStoreName, makeProcessedFieldsMerger, storeValueIsStoreObject, } from \"./helpers.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\n// Since there are only four possible combinations of context.clientOnly and\n// context.deferred values, we should need at most four \"flavors\" of any given\n// WriteContext. To avoid creating multiple copies of the same context, we cache\n// the contexts in the context.flavors Map (shared by all flavors) according to\n// their clientOnly and deferred values (always in that order).\nfunction getContextFlavor(context, clientOnly, deferred) {\n    const key = `${clientOnly}${deferred}`;\n    let flavored = context.flavors.get(key);\n    if (!flavored) {\n        context.flavors.set(key, (flavored =\n            context.clientOnly === clientOnly && context.deferred === deferred ?\n                context\n                : {\n                    ...context,\n                    clientOnly,\n                    deferred,\n                }));\n    }\n    return flavored;\n}\nexport class StoreWriter {\n    cache;\n    reader;\n    fragments;\n    constructor(cache, reader, fragments) {\n        this.cache = cache;\n        this.reader = reader;\n        this.fragments = fragments;\n    }\n    writeToStore(store, { query, result, dataId, variables, overwrite, }) {\n        const operationDefinition = getOperationDefinition(query);\n        const merger = makeProcessedFieldsMerger();\n        variables = {\n            ...getDefaultValues(operationDefinition),\n            ...variables,\n        };\n        const context = {\n            store,\n            written: {},\n            merge(existing, incoming) {\n                return merger.merge(existing, incoming);\n            },\n            variables: variables,\n            varString: canonicalStringify(variables),\n            ...extractFragmentContext(query, this.fragments),\n            overwrite: !!overwrite,\n            incomingById: new Map(),\n            clientOnly: false,\n            deferred: false,\n            flavors: new Map(),\n        };\n        const ref = this.processSelectionSet({\n            result: result || {},\n            dataId,\n            selectionSet: operationDefinition.selectionSet,\n            mergeTree: { map: new Map() },\n            context,\n        });\n        if (!isReference(ref)) {\n            throw newInvariantError(106, result);\n        }\n        // So far, the store has not been modified, so now it's time to process\n        // context.incomingById and merge those incoming fields into context.store.\n        context.incomingById.forEach(({ storeObject, mergeTree, fieldNodeSet }, dataId) => {\n            const entityRef = makeReference(dataId);\n            if (mergeTree && mergeTree.map.size) {\n                const applied = this.applyMerges(mergeTree, entityRef, storeObject, context);\n                if (isReference(applied)) {\n                    // Assume References returned by applyMerges have already been merged\n                    // into the store. See makeMergeObjectsFunction in policies.ts for an\n                    // example of how this can happen.\n                    return;\n                }\n                // Otherwise, applyMerges returned a StoreObject, whose fields we should\n                // merge into the store (see store.merge statement below).\n                storeObject = applied;\n            }\n            if (__DEV__ && !context.overwrite) {\n                const fieldsWithSelectionSets = {};\n                fieldNodeSet.forEach((field) => {\n                    if (field.selectionSet) {\n                        fieldsWithSelectionSets[field.name.value] = true;\n                    }\n                });\n                const hasSelectionSet = (storeFieldName) => fieldsWithSelectionSets[fieldNameFromStoreName(storeFieldName)] ===\n                    true;\n                const hasMergeFunction = (storeFieldName) => {\n                    const childTree = mergeTree && mergeTree.map.get(storeFieldName);\n                    return Boolean(childTree && childTree.info && childTree.info.merge);\n                };\n                Object.keys(storeObject).forEach((storeFieldName) => {\n                    // If a merge function was defined for this field, trust that it\n                    // did the right thing about (not) clobbering data. If the field\n                    // has no selection set, it's a scalar field, so it doesn't need\n                    // a merge function (even if it's an object, like JSON data).\n                    if (hasSelectionSet(storeFieldName) &&\n                        !hasMergeFunction(storeFieldName)) {\n                        warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n                    }\n                });\n            }\n            store.merge(dataId, storeObject);\n        });\n        // Any IDs written explicitly to the cache will be retained as\n        // reachable root IDs for garbage collection purposes. Although this\n        // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n        // retainment counts are effectively ignored because cache.gc() always\n        // includes them in its root ID set.\n        store.retain(ref.__ref);\n        return ref;\n    }\n    processSelectionSet({ dataId, result, selectionSet, context, \n    // This object allows processSelectionSet to report useful information\n    // to its callers without explicitly returning that information.\n    mergeTree, }) {\n        const { policies } = this.cache;\n        // This variable will be repeatedly updated using context.merge to\n        // accumulate all fields that need to be written into the store.\n        let incoming = {};\n        // If typename was not passed in, infer it. Note that typename is\n        // always passed in for tricky-to-infer cases such as \"Query\" for\n        // ROOT_QUERY.\n        const typename = (dataId && policies.rootTypenamesById[dataId]) ||\n            getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n            (dataId && context.store.get(dataId, \"__typename\"));\n        if (\"string\" === typeof typename) {\n            incoming.__typename = typename;\n        }\n        // This readField function will be passed as context.readField in the\n        // KeyFieldsContext object created within policies.identify (called below).\n        // In addition to reading from the existing context.store (thanks to the\n        // policies.readField(options, context) line at the very bottom), this\n        // version of readField can read from Reference objects that are currently\n        // pending in context.incomingById, which is important whenever keyFields\n        // need to be extracted from a child object that processSelectionSet has\n        // turned into a Reference.\n        const readField = (...args) => {\n            const options = normalizeReadFieldOptions(args, incoming, context.variables);\n            if (isReference(options.from)) {\n                const info = context.incomingById.get(options.from.__ref);\n                if (info) {\n                    const result = policies.readField({\n                        ...options,\n                        from: info.storeObject,\n                    }, context);\n                    if (result !== void 0) {\n                        return result;\n                    }\n                }\n            }\n            return policies.readField(options, context);\n        };\n        const fieldNodeSet = new Set();\n        this.flattenFields(selectionSet, result, \n        // This WriteContext will be the default context value for fields returned\n        // by the flattenFields method, but some fields may be assigned a modified\n        // context, depending on the presence of @client and other directives.\n        context, typename).forEach((context, field) => {\n            const resultFieldKey = resultKeyNameFromField(field);\n            const value = result[resultFieldKey];\n            fieldNodeSet.add(field);\n            if (value !== void 0) {\n                const storeFieldName = policies.getStoreFieldName({\n                    typename,\n                    fieldName: field.name.value,\n                    field,\n                    variables: context.variables,\n                });\n                const childTree = getChildMergeTree(mergeTree, storeFieldName);\n                let incomingValue = this.processFieldValue(value, field, \n                // Reset context.clientOnly and context.deferred to their default\n                // values before processing nested selection sets.\n                field.selectionSet ?\n                    getContextFlavor(context, false, false)\n                    : context, childTree);\n                // To determine if this field holds a child object with a merge function\n                // defined in its type policy (see PR #7070), we need to figure out the\n                // child object's __typename.\n                let childTypename;\n                // The field's value can be an object that has a __typename only if the\n                // field has a selection set. Otherwise incomingValue is scalar.\n                if (field.selectionSet &&\n                    (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {\n                    childTypename = readField(\"__typename\", incomingValue);\n                }\n                const merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n                if (merge) {\n                    childTree.info = {\n                        // TODO Check compatibility against any existing childTree.field?\n                        field,\n                        typename,\n                        merge,\n                    };\n                }\n                else {\n                    maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n                }\n                incoming = context.merge(incoming, {\n                    [storeFieldName]: incomingValue,\n                });\n            }\n            else if (__DEV__ &&\n                !context.clientOnly &&\n                !context.deferred &&\n                !addTypenameToDocument.added(field) &&\n                // If the field has a read function, it may be a synthetic field or\n                // provide a default value, so its absence from the written data should\n                // not be cause for alarm.\n                !policies.getReadFunction(typename, field.name.value)) {\n                invariant.error(107, resultKeyNameFromField(field), result);\n            }\n        });\n        // Identify the result object, even if dataId was already provided,\n        // since we always need keyObject below.\n        try {\n            const [id, keyObject] = policies.identify(result, {\n                typename,\n                selectionSet,\n                fragmentMap: context.fragmentMap,\n                storeObject: incoming,\n                readField,\n            });\n            // If dataId was not provided, fall back to the id just generated by\n            // policies.identify.\n            dataId = dataId || id;\n            // Write any key fields that were used during identification, even if\n            // they were not mentioned in the original query.\n            if (keyObject) {\n                // TODO Reverse the order of the arguments?\n                incoming = context.merge(incoming, keyObject);\n            }\n        }\n        catch (e) {\n            // If dataId was provided, tolerate failure of policies.identify.\n            if (!dataId)\n                throw e;\n        }\n        if (\"string\" === typeof dataId) {\n            const dataRef = makeReference(dataId);\n            // Avoid processing the same entity object using the same selection\n            // set more than once. We use an array instead of a Set since most\n            // entity IDs will be written using only one selection set, so the\n            // size of this array is likely to be very small, meaning indexOf is\n            // likely to be faster than Set.prototype.has.\n            const sets = context.written[dataId] || (context.written[dataId] = []);\n            if (sets.indexOf(selectionSet) >= 0)\n                return dataRef;\n            sets.push(selectionSet);\n            // If we're about to write a result object into the store, but we\n            // happen to know that the exact same (===) result object would be\n            // returned if we were to reread the result with the same inputs,\n            // then we can skip the rest of the processSelectionSet work for\n            // this object, and immediately return a Reference to it.\n            if (this.reader &&\n                this.reader.isFresh(result, dataRef, selectionSet, context)) {\n                return dataRef;\n            }\n            const previous = context.incomingById.get(dataId);\n            if (previous) {\n                previous.storeObject = context.merge(previous.storeObject, incoming);\n                previous.mergeTree = mergeMergeTrees(previous.mergeTree, mergeTree);\n                fieldNodeSet.forEach((field) => previous.fieldNodeSet.add(field));\n            }\n            else {\n                context.incomingById.set(dataId, {\n                    storeObject: incoming,\n                    // Save a reference to mergeTree only if it is not empty, because\n                    // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n                    // reused for entirely different parts of the result tree.\n                    mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n                    fieldNodeSet,\n                });\n            }\n            return dataRef;\n        }\n        return incoming;\n    }\n    processFieldValue(value, field, context, mergeTree) {\n        if (!field.selectionSet || value === null) {\n            // In development, we need to clone scalar values so that they can be\n            // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n            // it's cheaper to store the scalar values directly in the cache.\n            return __DEV__ ? cloneDeep(value) : value;\n        }\n        if (isArray(value)) {\n            return value.map((item, i) => {\n                const value = this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n                maybeRecycleChildMergeTree(mergeTree, i);\n                return value;\n            });\n        }\n        return this.processSelectionSet({\n            result: value,\n            selectionSet: field.selectionSet,\n            context,\n            mergeTree,\n        });\n    }\n    // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with\n    // some additions for tracking @client and @defer directives.\n    flattenFields(selectionSet, result, context, typename = getTypenameFromResult(result, selectionSet, context.fragmentMap)) {\n        const fieldMap = new Map();\n        const { policies } = this.cache;\n        const limitingTrie = new Trie(false); // No need for WeakMap, since limitingTrie does not escape.\n        (function flatten(selectionSet, inheritedContext) {\n            const visitedNode = limitingTrie.lookup(selectionSet, \n            // Because we take inheritedClientOnly and inheritedDeferred into\n            // consideration here (in addition to selectionSet), it's possible for\n            // the same selection set to be flattened more than once, if it appears\n            // in the query with different @client and/or @directive configurations.\n            inheritedContext.clientOnly, inheritedContext.deferred);\n            if (visitedNode.visited)\n                return;\n            visitedNode.visited = true;\n            selectionSet.selections.forEach((selection) => {\n                if (!shouldInclude(selection, context.variables))\n                    return;\n                let { clientOnly, deferred } = inheritedContext;\n                if (\n                // Since the presence of @client or @defer on this field can only\n                // cause clientOnly or deferred to become true, we can skip the\n                // forEach loop if both clientOnly and deferred are already true.\n                !(clientOnly && deferred) &&\n                    isNonEmptyArray(selection.directives)) {\n                    selection.directives.forEach((dir) => {\n                        const name = dir.name.value;\n                        if (name === \"client\")\n                            clientOnly = true;\n                        if (name === \"defer\") {\n                            const args = argumentsObjectFromField(dir, context.variables);\n                            // The @defer directive takes an optional args.if boolean\n                            // argument, similar to @include(if: boolean). Note that\n                            // @defer(if: false) does not make context.deferred false, but\n                            // instead behaves as if there was no @defer directive.\n                            if (!args || args.if !== false) {\n                                deferred = true;\n                            }\n                            // TODO In the future, we may want to record args.label using\n                            // context.deferred, if a label is specified.\n                        }\n                    });\n                }\n                if (isField(selection)) {\n                    const existing = fieldMap.get(selection);\n                    if (existing) {\n                        // If this field has been visited along another recursive path\n                        // before, the final context should have clientOnly or deferred set\n                        // to true only if *all* paths have the directive (hence the &&).\n                        clientOnly = clientOnly && existing.clientOnly;\n                        deferred = deferred && existing.deferred;\n                    }\n                    fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n                }\n                else {\n                    const fragment = getFragmentFromSelection(selection, context.lookupFragment);\n                    if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n                        throw newInvariantError(108, selection.name.value);\n                    }\n                    if (fragment &&\n                        policies.fragmentMatches(fragment, typename, result, context.variables)) {\n                        flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n                    }\n                }\n            });\n        })(selectionSet, context);\n        return fieldMap;\n    }\n    applyMerges(mergeTree, existing, incoming, context, getStorageArgs) {\n        if (mergeTree.map.size && !isReference(incoming)) {\n            const e = \n            // Items in the same position in different arrays are not\n            // necessarily related to each other, so when incoming is an array\n            // we process its elements as if there was no existing data.\n            (!isArray(incoming) &&\n                // Likewise, existing must be either a Reference or a StoreObject\n                // in order for its fields to be safe to merge with the fields of\n                // the incoming object.\n                (isReference(existing) || storeValueIsStoreObject(existing))) ?\n                existing\n                : void 0;\n            // This narrowing is implied by mergeTree.map.size > 0 and\n            // !isReference(incoming), though TypeScript understandably cannot\n            // hope to infer this type.\n            const i = incoming;\n            // The options.storage objects provided to read and merge functions\n            // are derived from the identity of the parent object plus a\n            // sequence of storeFieldName strings/numbers identifying the nested\n            // field name path of each field value to be merged.\n            if (e && !getStorageArgs) {\n                getStorageArgs = [isReference(e) ? e.__ref : e];\n            }\n            // It's possible that applying merge functions to this subtree will\n            // not change the incoming data, so this variable tracks the fields\n            // that did change, so we can create a new incoming object when (and\n            // only when) at least one incoming field has changed. We use a Map\n            // to preserve the type of numeric keys.\n            let changedFields;\n            const getValue = (from, name) => {\n                return (isArray(from) ?\n                    typeof name === \"number\" ?\n                        from[name]\n                        : void 0\n                    : context.store.getFieldValue(from, String(name)));\n            };\n            mergeTree.map.forEach((childTree, storeFieldName) => {\n                const eVal = getValue(e, storeFieldName);\n                const iVal = getValue(i, storeFieldName);\n                // If we have no incoming data, leave any existing data untouched.\n                if (void 0 === iVal)\n                    return;\n                if (getStorageArgs) {\n                    getStorageArgs.push(storeFieldName);\n                }\n                const aVal = this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n                if (aVal !== iVal) {\n                    changedFields = changedFields || new Map();\n                    changedFields.set(storeFieldName, aVal);\n                }\n                if (getStorageArgs) {\n                    invariant(getStorageArgs.pop() === storeFieldName);\n                }\n            });\n            if (changedFields) {\n                // Shallow clone i so we can add changed fields to it.\n                incoming = (isArray(i) ? i.slice(0) : { ...i });\n                changedFields.forEach((value, name) => {\n                    incoming[name] = value;\n                });\n            }\n        }\n        if (mergeTree.info) {\n            return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && context.store.getStorage(...getStorageArgs));\n        }\n        return incoming;\n    }\n}\nconst emptyMergeTreePool = [];\nfunction getChildMergeTree({ map }, name) {\n    if (!map.has(name)) {\n        map.set(name, emptyMergeTreePool.pop() || { map: new Map() });\n    }\n    return map.get(name);\n}\nfunction mergeMergeTrees(left, right) {\n    if (left === right || !right || mergeTreeIsEmpty(right))\n        return left;\n    if (!left || mergeTreeIsEmpty(left))\n        return right;\n    const info = left.info && right.info ?\n        {\n            ...left.info,\n            ...right.info,\n        }\n        : left.info || right.info;\n    const needToMergeMaps = left.map.size && right.map.size;\n    const map = needToMergeMaps ? new Map()\n        : left.map.size ? left.map\n            : right.map;\n    const merged = { info, map };\n    if (needToMergeMaps) {\n        const remainingRightKeys = new Set(right.map.keys());\n        left.map.forEach((leftTree, key) => {\n            merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n            remainingRightKeys.delete(key);\n        });\n        remainingRightKeys.forEach((key) => {\n            merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n        });\n    }\n    return merged;\n}\nfunction mergeTreeIsEmpty(tree) {\n    return !tree || !(tree.info || tree.map.size);\n}\nfunction maybeRecycleChildMergeTree({ map }, name) {\n    const childTree = map.get(name);\n    if (childTree && mergeTreeIsEmpty(childTree)) {\n        emptyMergeTreePool.push(childTree);\n        map.delete(name);\n    }\n}\nconst warnings = new Set();\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n    const getChild = (objOrRef) => {\n        const child = store.getFieldValue(objOrRef, storeFieldName);\n        return typeof child === \"object\" && child;\n    };\n    const existing = getChild(existingRef);\n    if (!existing)\n        return;\n    const incoming = getChild(incomingObj);\n    if (!incoming)\n        return;\n    // It's always safe to replace a reference, since it refers to data\n    // safely stored elsewhere.\n    if (isReference(existing))\n        return;\n    // If the values are structurally equivalent, we do not need to worry\n    // about incoming replacing existing.\n    if (equal(existing, incoming))\n        return;\n    // If we're replacing every key of the existing object, then the\n    // existing data would be overwritten even if the objects were\n    // normalized, so warning would not be helpful here.\n    if (Object.keys(existing).every((key) => store.getFieldValue(incoming, key) !== void 0)) {\n        return;\n    }\n    const parentType = store.getFieldValue(existingRef, \"__typename\") ||\n        store.getFieldValue(incomingObj, \"__typename\");\n    const fieldName = fieldNameFromStoreName(storeFieldName);\n    const typeDotName = `${parentType}.${fieldName}`;\n    // Avoid warning more than once for the same type and field name.\n    if (warnings.has(typeDotName))\n        return;\n    warnings.add(typeDotName);\n    const childTypenames = [];\n    // Arrays do not have __typename fields, and always need a custom merge\n    // function, even if their elements are normalized entities.\n    if (!isArray(existing) && !isArray(incoming)) {\n        [existing, incoming].forEach((child) => {\n            const typename = store.getFieldValue(child, \"__typename\");\n            if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n                childTypenames.push(typename);\n            }\n        });\n    }\n    __DEV__ && invariant.warn(109, fieldName, parentType, childTypenames.length ?\n        \"either ensure all objects of type \" +\n            childTypenames.join(\" and \") +\n            \" have an ID or a custom merge function, or \"\n        : \"\", typeDotName, { ...existing }, { ...incoming });\n}\nfunction getTypenameFromResult(result, selectionSet, fragmentMap) {\n    let fragments;\n    for (const selection of selectionSet.selections) {\n        if (isField(selection)) {\n            if (selection.name.value === \"__typename\") {\n                return result[resultKeyNameFromField(selection)];\n            }\n        }\n        else if (fragments) {\n            fragments.push(selection);\n        }\n        else {\n            fragments = [selection];\n        }\n    }\n    if (typeof result.__typename === \"string\") {\n        return result.__typename;\n    }\n    if (fragments) {\n        for (const selection of fragments) {\n            const typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);\n            if (typeof typename === \"string\") {\n                return typename;\n            }\n        }\n    }\n}\n\n", "import { equal } from \"@wry/equality\";\nimport { wrap } from \"optimism\";\nimport { addTypenameToDocument, cacheSizes, canonicalStringify, DocumentTransform, isReference, print, } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { getInMemoryCacheMemoryInternals } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { ApolloCache } from \"../core/cache.js\";\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { hasOwn, normalizeConfig } from \"./helpers.js\";\nimport { Policies } from \"./policies.js\";\nimport { forgetCache, makeVar, recallCache } from \"./reactiveVars.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\nexport class InMemoryCache extends ApolloCache {\n    data;\n    optimisticData;\n    config;\n    watches = new Set();\n    storeReader;\n    storeWriter;\n    addTypenameTransform = new DocumentTransform(addTypenameToDocument);\n    maybeBroadcastWatch;\n    // Override the default value, since InMemoryCache result objects are frozen\n    // in development and expected to remain logically immutable in production.\n    assumeImmutableResults = true;\n    // Dynamically imported code can augment existing typePolicies or\n    // possibleTypes by calling cache.policies.addTypePolicies or\n    // cache.policies.addPossibletypes.\n    policies;\n    makeVar = makeVar;\n    constructor(config = {}) {\n        super();\n        this.config = normalizeConfig(config);\n        this.policies = new Policies({\n            cache: this,\n            dataIdFromObject: this.config.dataIdFromObject,\n            possibleTypes: this.config.possibleTypes,\n            typePolicies: this.config.typePolicies,\n        });\n        this.init();\n    }\n    init() {\n        // Passing { resultCaching: false } in the InMemoryCache constructor options\n        // will completely disable dependency tracking, which will improve memory\n        // usage but worsen the performance of repeated reads.\n        const rootStore = (this.data = new EntityStore.Root({\n            policies: this.policies,\n            resultCaching: this.config.resultCaching,\n        }));\n        // When no optimistic writes are currently active, cache.optimisticData ===\n        // cache.data, so there are no additional layers on top of the actual data.\n        // When an optimistic update happens, this.optimisticData will become a\n        // linked list of EntityStore Layer objects that terminates with the\n        // original this.data cache object.\n        this.optimisticData = rootStore.stump;\n        this.resetResultCache();\n    }\n    resetResultCache() {\n        const { fragments } = this.config;\n        this.addTypenameTransform.resetCache();\n        fragments?.resetCaches();\n        // The StoreWriter is mostly stateless and so doesn't really need to be\n        // reset, but it does need to have its writer.storeReader reference updated,\n        // so it's simpler to update this.storeWriter as well.\n        this.storeWriter = new StoreWriter(this, (this.storeReader = new StoreReader({ cache: this, fragments })), fragments);\n        this.maybeBroadcastWatch = wrap((c, options) => {\n            return this.broadcastWatch(c, options);\n        }, {\n            max: cacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] ||\n                5000 /* defaultCacheSizes[\"inMemoryCache.maybeBroadcastWatch\"] */,\n            makeCacheKey: (c) => {\n                // Return a cache key (thus enabling result caching) only if we're\n                // currently using a data store that can track cache dependencies.\n                const store = c.optimistic ? this.optimisticData : this.data;\n                if (supportsResultCaching(store)) {\n                    const { optimistic, id, variables } = c;\n                    return store.makeCacheKey(c.query, \n                    // Different watches can have the same query, optimistic\n                    // status, rootId, and variables, but if their callbacks are\n                    // different, the (identical) result needs to be delivered to\n                    // each distinct callback. The easiest way to achieve that\n                    // separation is to include c.callback in the cache key for\n                    // maybeBroadcastWatch calls. See issue #5733.\n                    c.callback, canonicalStringify({ optimistic, id, variables }));\n                }\n            },\n        });\n        // Since we have thrown away all the cached functions that depend on the\n        // CacheGroup dependencies maintained by EntityStore, we should also reset\n        // all CacheGroup dependency information.\n        new Set([this.data.group, this.optimisticData.group]).forEach((group) => group.resetCaching());\n    }\n    restore(data) {\n        this.init();\n        // Since calling this.init() discards/replaces the entire StoreReader, along\n        // with the result caches it maintains, this.data.replace(data) won't have\n        // to bother deleting the old data.\n        if (data)\n            this.data.replace(data);\n        return this;\n    }\n    extract(optimistic = false) {\n        return (optimistic ? this.optimisticData : this.data).extract();\n    }\n    read(options) {\n        const { \n        // Since read returns data or null, without any additional metadata\n        // about whether/where there might have been missing fields, the\n        // default behavior cannot be returnPartialData = true (like it is\n        // for the diff method), since defaulting to true would violate the\n        // integrity of the T in the return type. However, partial data may\n        // be useful in some cases, so returnPartialData:true may be\n        // specified explicitly.\n        returnPartialData = false, } = options;\n        return this.storeReader.diffQueryAgainstStore({\n            ...options,\n            store: options.optimistic ? this.optimisticData : this.data,\n            config: this.config,\n            returnPartialData,\n        }).result;\n    }\n    write(options) {\n        try {\n            ++this.txCount;\n            return this.storeWriter.writeToStore(this.data, options);\n        }\n        finally {\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    }\n    modify(options) {\n        if (hasOwn.call(options, \"id\") && !options.id) {\n            // To my knowledge, TypeScript does not currently provide a way to\n            // enforce that an optional property?:type must *not* be undefined\n            // when present. That ability would be useful here, because we want\n            // options.id to default to ROOT_QUERY only when no options.id was\n            // provided. If the caller attempts to pass options.id with a\n            // falsy/undefined value (perhaps because cache.identify failed), we\n            // should not assume the goal was to modify the ROOT_QUERY object.\n            // We could throw, but it seems natural to return false to indicate\n            // that nothing was modified.\n            return false;\n        }\n        const store = ((options.optimistic) // Defaults to false.\n        ) ?\n            this.optimisticData\n            : this.data;\n        try {\n            ++this.txCount;\n            return store.modify(options.id || \"ROOT_QUERY\", options.fields, false);\n        }\n        finally {\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    }\n    diff(options) {\n        return this.storeReader.diffQueryAgainstStore({\n            ...options,\n            store: options.optimistic ? this.optimisticData : this.data,\n            rootId: options.id || \"ROOT_QUERY\",\n            config: this.config,\n        });\n    }\n    watch(watch) {\n        if (!this.watches.size) {\n            // In case we previously called forgetCache(this) because\n            // this.watches became empty (see below), reattach this cache to any\n            // reactive variables on which it previously depended. It might seem\n            // paradoxical that we're able to recall something we supposedly\n            // forgot, but the point of calling forgetCache(this) is to silence\n            // useless broadcasts while this.watches is empty, and to allow the\n            // cache to be garbage collected. If, however, we manage to call\n            // recallCache(this) here, this cache object must not have been\n            // garbage collected yet, and should resume receiving updates from\n            // reactive variables, now that it has a watcher to notify.\n            recallCache(this);\n        }\n        this.watches.add(watch);\n        if (watch.immediate) {\n            this.maybeBroadcastWatch(watch);\n        }\n        return () => {\n            // Once we remove the last watch from this.watches, cache.broadcastWatches\n            // no longer does anything, so we preemptively tell the reactive variable\n            // system to exclude this cache from future broadcasts.\n            if (this.watches.delete(watch) && !this.watches.size) {\n                forgetCache(this);\n            }\n            // Remove this watch from the LRU cache managed by the\n            // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n            // leaks involving the closure of watch.callback.\n            this.maybeBroadcastWatch.forget(watch);\n        };\n    }\n    gc(options) {\n        canonicalStringify.reset();\n        print.reset();\n        const ids = this.optimisticData.gc();\n        if (options && !this.txCount && options.resetResultCache) {\n            this.resetResultCache();\n        }\n        return ids;\n    }\n    // Call this method to ensure the given root ID remains in the cache after\n    // garbage collection, along with its transitive child entities. Note that\n    // the cache automatically retains all directly written entities. By default,\n    // the retainment persists after optimistic updates are removed. Pass true\n    // for the optimistic argument if you would prefer for the retainment to be\n    // discarded when the top-most optimistic layer is removed. Returns the\n    // resulting (non-negative) retainment count.\n    retain(rootId, optimistic) {\n        return (optimistic ? this.optimisticData : this.data).retain(rootId);\n    }\n    // Call this method to undo the effect of the retain method, above. Once the\n    // retainment count falls to zero, the given ID will no longer be preserved\n    // during garbage collection, though it may still be preserved by other safe\n    // entities that refer to it. Returns the resulting (non-negative) retainment\n    // count, in case that's useful.\n    release(rootId, optimistic) {\n        return (optimistic ? this.optimisticData : this.data).release(rootId);\n    }\n    // Returns the canonical ID for a given StoreObject, obeying typePolicies\n    // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n    // the object must contain a __typename and any primary key fields required\n    // to identify entities of that type. If you pass a query result object, be\n    // sure that none of the primary key fields have been renamed by aliasing.\n    // If you pass a Reference object, its __ref ID string will be returned.\n    identify(object) {\n        if (isReference(object))\n            return object.__ref;\n        try {\n            return this.policies.identify(object)[0];\n        }\n        catch (e) {\n            __DEV__ && invariant.warn(e);\n        }\n    }\n    evict(options) {\n        if (!options.id) {\n            if (hasOwn.call(options, \"id\")) {\n                // See comment in modify method about why we return false when\n                // options.id exists but is falsy/undefined.\n                return false;\n            }\n            options = { ...options, id: \"ROOT_QUERY\" };\n        }\n        try {\n            // It's unlikely that the eviction will end up invoking any other\n            // cache update operations while it's running, but {in,de}crementing\n            // this.txCount still seems like a good idea, for uniformity with\n            // the other update methods.\n            ++this.txCount;\n            // Pass this.data as a limit on the depth of the eviction, so evictions\n            // during optimistic updates (when this.data is temporarily set equal to\n            // this.optimisticData) do not escape their optimistic Layer.\n            return this.optimisticData.evict(options, this.data);\n        }\n        finally {\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    }\n    reset(options) {\n        this.init();\n        canonicalStringify.reset();\n        if (options && options.discardWatches) {\n            // Similar to what happens in the unsubscribe function returned by\n            // cache.watch, applied to all current watches.\n            this.watches.forEach((watch) => this.maybeBroadcastWatch.forget(watch));\n            this.watches.clear();\n            forgetCache(this);\n        }\n        else {\n            // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n            // this.broadcastWatches() triggers a broadcast to every current watcher\n            // (letting them know their data is now missing). This default behavior is\n            // convenient because it means the watches do not have to be manually\n            // reestablished after resetting the cache. To prevent this broadcast and\n            // cancel all watches, pass true for options.discardWatches.\n            this.broadcastWatches();\n        }\n        return Promise.resolve();\n    }\n    removeOptimistic(idToRemove) {\n        const newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n        if (newOptimisticData !== this.optimisticData) {\n            this.optimisticData = newOptimisticData;\n            this.broadcastWatches();\n        }\n    }\n    txCount = 0;\n    batch(options) {\n        const { update, optimistic = true, removeOptimistic, onWatchUpdated, } = options;\n        let updateResult;\n        const perform = (layer) => {\n            const { data, optimisticData } = this;\n            ++this.txCount;\n            if (layer) {\n                this.data = this.optimisticData = layer;\n            }\n            try {\n                return (updateResult = update(this));\n            }\n            finally {\n                --this.txCount;\n                this.data = data;\n                this.optimisticData = optimisticData;\n            }\n        };\n        const alreadyDirty = new Set();\n        if (onWatchUpdated && !this.txCount) {\n            // If an options.onWatchUpdated callback is provided, we want to call it\n            // with only the Cache.WatchOptions objects affected by options.update,\n            // but there might be dirty watchers already waiting to be broadcast that\n            // have nothing to do with the update. To prevent including those watchers\n            // in the post-update broadcast, we perform this initial broadcast to\n            // collect the dirty watchers, so we can re-dirty them later, after the\n            // post-update broadcast, allowing them to receive their pending\n            // broadcasts the next time broadcastWatches is called, just as they would\n            // if we never called cache.batch.\n            this.broadcastWatches({\n                ...options,\n                onWatchUpdated(watch) {\n                    alreadyDirty.add(watch);\n                    return false;\n                },\n            });\n        }\n        if (typeof optimistic === \"string\") {\n            // Note that there can be multiple layers with the same optimistic ID.\n            // When removeOptimistic(id) is called for that id, all matching layers\n            // will be removed, and the remaining layers will be reapplied.\n            this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n        }\n        else if (optimistic === false) {\n            // Ensure both this.data and this.optimisticData refer to the root\n            // (non-optimistic) layer of the cache during the update. Note that\n            // this.data could be a Layer if we are currently executing an optimistic\n            // update function, but otherwise will always be an EntityStore.Root\n            // instance.\n            perform(this.data);\n        }\n        else {\n            // Otherwise, leave this.data and this.optimisticData unchanged and run\n            // the update with broadcast batching.\n            perform();\n        }\n        if (typeof removeOptimistic === \"string\") {\n            this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n        }\n        // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n        // takes the else branch and calls this.broadcastWatches(options), which\n        // does nothing when this.txCount > 0.\n        if (onWatchUpdated && alreadyDirty.size) {\n            this.broadcastWatches({\n                ...options,\n                onWatchUpdated(watch, diff) {\n                    const result = onWatchUpdated.call(this, watch, diff);\n                    if (result !== false) {\n                        // Since onWatchUpdated did not return false, this diff is\n                        // about to be broadcast to watch.callback, so we don't need\n                        // to re-dirty it with the other alreadyDirty watches below.\n                        alreadyDirty.delete(watch);\n                    }\n                    return result;\n                },\n            });\n            // Silently re-dirty any watches that were already dirty before the update\n            // was performed, and were not broadcast just now.\n            if (alreadyDirty.size) {\n                alreadyDirty.forEach((watch) => this.maybeBroadcastWatch.dirty(watch));\n            }\n        }\n        else {\n            // If alreadyDirty is empty or we don't have an onWatchUpdated\n            // function, we don't need to go to the trouble of wrapping\n            // options.onWatchUpdated.\n            this.broadcastWatches(options);\n        }\n        return updateResult;\n    }\n    performTransaction(update, optimisticId) {\n        return this.batch({\n            update,\n            optimistic: optimisticId || optimisticId !== null,\n        });\n    }\n    transformDocument(document) {\n        return this.addTypenameTransform.transformDocument(this.addFragmentsToDocument(document));\n    }\n    fragmentMatches(fragment, typename) {\n        return this.policies.fragmentMatches(fragment, typename);\n    }\n    lookupFragment(fragmentName) {\n        return this.config.fragments?.lookup(fragmentName) || null;\n    }\n    broadcastWatches(options) {\n        if (!this.txCount) {\n            this.watches.forEach((c) => this.maybeBroadcastWatch(c, options));\n        }\n    }\n    addFragmentsToDocument(document) {\n        const { fragments } = this.config;\n        return fragments ? fragments.transform(document) : document;\n    }\n    // This method is wrapped by maybeBroadcastWatch, which is called by\n    // broadcastWatches, so that we compute and broadcast results only when\n    // the data that would be broadcast might have changed. It would be\n    // simpler to check for changes after recomputing a result but before\n    // broadcasting it, but this wrapping approach allows us to skip both\n    // the recomputation and the broadcast, in most cases.\n    broadcastWatch(c, options) {\n        const { lastDiff } = c;\n        // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n        // currently requires no additional properties, so we can use c (a\n        // WatchOptions object) as DiffOptions, without having to allocate a new\n        // object, and without having to enumerate the relevant properties (query,\n        // variables, etc.) explicitly. There will be some additional properties\n        // (lastDiff, callback, etc.), but cache.diff ignores them.\n        const diff = this.diff(c);\n        if (options) {\n            if (c.optimistic && typeof options.optimistic === \"string\") {\n                diff.fromOptimisticTransaction = true;\n            }\n            if (options.onWatchUpdated &&\n                options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {\n                // Returning false from the onWatchUpdated callback will prevent\n                // calling c.callback(diff) for this watcher.\n                return;\n            }\n        }\n        if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n            c.callback((c.lastDiff = diff), lastDiff);\n        }\n    }\n}\nif (__DEV__) {\n    InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;\n}\n\n", "/**\n * The current status of a querys execution in our system.\n */\nexport var NetworkStatus;\n(function (NetworkStatus) {\n    /**\n     * The query has never been run before and the query is now currently running. A query will still\n     * have this network status even if a partial data result was returned from the cache, but a\n     * query was dispatched anyway.\n     */\n    NetworkStatus[NetworkStatus[\"loading\"] = 1] = \"loading\";\n    /**\n     * If `setVariables` was called and a query was fired because of that then the network status\n     * will be `setVariables` until the result of that query comes back.\n     */\n    NetworkStatus[NetworkStatus[\"setVariables\"] = 2] = \"setVariables\";\n    /**\n     * Indicates that `fetchMore` was called on this query and that the query created is currently in\n     * flight.\n     */\n    NetworkStatus[NetworkStatus[\"fetchMore\"] = 3] = \"fetchMore\";\n    /**\n     * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n     * and the refetch request is currently in flight.\n     */\n    NetworkStatus[NetworkStatus[\"refetch\"] = 4] = \"refetch\";\n    /**\n     * Indicates that a polling query is currently in flight. So for example if you are polling a\n     * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n     * a poll request has been sent but not resolved.\n     */\n    NetworkStatus[NetworkStatus[\"poll\"] = 6] = \"poll\";\n    /**\n     * No request is in flight for this query, and no errors happened. Everything is OK.\n     */\n    NetworkStatus[NetworkStatus[\"ready\"] = 7] = \"ready\";\n    /**\n     * No request is in flight for this query, but one or more errors were detected.\n     */\n    NetworkStatus[NetworkStatus[\"error\"] = 8] = \"error\";\n    /**\n     * Indicates that a `@defer` query has received at least the first chunk of\n     * the result but the full result has not yet been fully streamed to the\n     * client.\n     */\n    NetworkStatus[NetworkStatus[\"streaming\"] = 9] = \"streaming\";\n})(NetworkStatus || (NetworkStatus = {}));\n", "import { equal } from \"@wry/equality\";\nimport { BehaviorSubject, Observable, share, Subject, tap } from \"rxjs\";\nimport { isNetworkRequestInFlight } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { compact, equalByQuery, filterMap, getOperationDefinition, getOperationName, getQueryDefinition, preventUnhandledRejection, toQueryResult, variablesUnknownSymbol, } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { NetworkStatus } from \"./networkStatus.js\";\nconst { assign, hasOwnProperty } = Object;\nconst uninitialized = {\n    loading: true,\n    networkStatus: NetworkStatus.loading,\n    data: undefined,\n    dataState: \"empty\",\n    partial: true,\n};\nconst empty = {\n    loading: false,\n    networkStatus: NetworkStatus.ready,\n    data: undefined,\n    dataState: \"empty\",\n    partial: true,\n};\nexport class ObservableQuery {\n    options;\n    queryName;\n    variablesUnknown = false;\n    /**\n    * @internal will be read and written from `QueryInfo`\n    * \n    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n    */\n    _lastWrite;\n    // The `query` computed property will always reflect the document transformed\n    // by the last run query. `this.options.query` will always reflect the raw\n    // untransformed query to ensure document transforms with runtime conditionals\n    // are run on the original document.\n    get query() {\n        return this.lastQuery;\n    }\n    /**\n     * An object containing the variables that were provided for the query.\n     */\n    get variables() {\n        return this.options.variables;\n    }\n    unsubscribeFromCache;\n    input;\n    subject;\n    isTornDown;\n    queryManager;\n    subscriptions = new Set();\n    /**\n     * If an `ObservableQuery` is created with a `network-only` fetch policy,\n     * it should actually start receiving cache updates, but not before it has\n     * received the first result from the network.\n     */\n    waitForNetworkResult;\n    lastQuery;\n    linkSubscription;\n    pollingInfo;\n    get networkStatus() {\n        return this.subject.getValue().result.networkStatus;\n    }\n    constructor({ queryManager, options, transformedQuery = queryManager.transform(options.query), }) {\n        this.queryManager = queryManager;\n        // active state\n        this.waitForNetworkResult = options.fetchPolicy === \"network-only\";\n        this.isTornDown = false;\n        this.subscribeToMore = this.subscribeToMore.bind(this);\n        this.maskResult = this.maskResult.bind(this);\n        const { watchQuery: { fetchPolicy: defaultFetchPolicy = \"cache-first\" } = {}, } = queryManager.defaultOptions;\n        const { fetchPolicy = defaultFetchPolicy, \n        // Make sure we don't store \"standby\" as the initialFetchPolicy.\n        initialFetchPolicy = fetchPolicy === \"standby\" ? defaultFetchPolicy : (fetchPolicy), } = options;\n        if (options[variablesUnknownSymbol]) {\n            invariant(fetchPolicy === \"standby\", 77);\n            this.variablesUnknown = true;\n        }\n        this.lastQuery = transformedQuery;\n        this.options = {\n            ...options,\n            // Remember the initial options.fetchPolicy so we can revert back to this\n            // policy when variables change. This information can also be specified\n            // (or overridden) by providing options.initialFetchPolicy explicitly.\n            initialFetchPolicy,\n            // This ensures this.options.fetchPolicy always has a string value, in\n            // case options.fetchPolicy was not provided.\n            fetchPolicy,\n            variables: this.getVariablesWithDefaults(options.variables),\n        };\n        this.initializeObservablesQueue();\n        this[\"@@observable\"] = () => this;\n        if (Symbol.observable) {\n            this[Symbol.observable] = () => this;\n        }\n        const opDef = getOperationDefinition(this.query);\n        this.queryName = opDef && opDef.name && opDef.name.value;\n    }\n    initializeObservablesQueue() {\n        this.subject = new BehaviorSubject({\n            query: this.query,\n            variables: this.variables,\n            result: uninitialized,\n            meta: {},\n        });\n        const observable = this.subject.pipe(tap({\n            subscribe: () => {\n                if (!this.subject.observed) {\n                    this.reobserve();\n                    // TODO: See if we can rework updatePolling to better handle this.\n                    // reobserve calls updatePolling but this `subscribe` callback is\n                    // called before the subject is subscribed to so `updatePolling`\n                    // can't accurately detect if there is an active subscription.\n                    // Calling it again here ensures that it can detect if it can poll\n                    setTimeout(() => this.updatePolling());\n                }\n            },\n            unsubscribe: () => {\n                if (!this.subject.observed) {\n                    this.tearDownQuery();\n                }\n            },\n        }), filterMap(({ query, variables, result: current, meta }, context) => {\n            const { shouldEmit } = meta;\n            if (current === uninitialized) {\n                // reset internal state after `ObservableQuery.reset()`\n                context.previous = undefined;\n                context.previousVariables = undefined;\n            }\n            if (this.options.fetchPolicy === \"standby\" ||\n                shouldEmit === 2 /* EmitBehavior.never */)\n                return;\n            if (shouldEmit === 1 /* EmitBehavior.force */)\n                return emit();\n            const { previous, previousVariables } = context;\n            if (previous) {\n                const documentInfo = this.queryManager.getDocumentInfo(query);\n                const dataMasking = this.queryManager.dataMasking;\n                const maskedQuery = dataMasking ? documentInfo.nonReactiveQuery : query;\n                const resultIsEqual = dataMasking || documentInfo.hasNonreactiveDirective ?\n                    equalByQuery(maskedQuery, previous, current, variables)\n                    : equal(previous, current);\n                if (resultIsEqual && equal(previousVariables, variables)) {\n                    return;\n                }\n            }\n            if (shouldEmit === 3 /* EmitBehavior.networkStatusChange */ &&\n                (!this.options.notifyOnNetworkStatusChange ||\n                    equal(previous, current))) {\n                return;\n            }\n            return emit();\n            function emit() {\n                context.previous = current;\n                context.previousVariables = variables;\n                return current;\n            }\n        }, () => ({})));\n        this.pipe = observable.pipe.bind(observable);\n        this.subscribe = observable.subscribe.bind(observable);\n        this.input = new Subject();\n        // we want to feed many streams into `this.subject`, but none of them should\n        // be able to close `this.input`\n        this.input.complete = () => { };\n        this.input.pipe(this.operator).subscribe(this.subject);\n    }\n    // We can't use Observable['subscribe'] here as the type as it conflicts with\n    // the ability to infer T from Subscribable<T>. This limits the surface area\n    // to the non-deprecated signature which works properly with type inference.\n    /**\n     * Subscribes to the `ObservableQuery`.\n     * @param observerOrNext - Either an RxJS `Observer` with some or all callback methods,\n     * or the `next` handler that is called for each value emitted from the subscribed Observable.\n     * @returns A subscription reference to the registered handlers.\n     */\n    subscribe;\n    /**\n     * Used to stitch together functional operators into a chain.\n     *\n     * @example\n     *\n     * ```ts\n     * import { filter, map } from 'rxjs';\n     *\n     * observableQuery\n     *   .pipe(\n     *     filter(...),\n     *     map(...),\n     *   )\n     *   .subscribe(x => console.log(x));\n     * ```\n     *\n     * @returns The Observable result of all the operators having been called\n     * in the order they were passed in.\n     */\n    pipe;\n    [Symbol.observable];\n    [\"@@observable\"];\n    /**\n    * @internal\n    * \n    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n    */\n    getCacheDiff({ optimistic = true } = {}) {\n        return this.queryManager.cache.diff({\n            query: this.query,\n            variables: this.variables,\n            returnPartialData: true,\n            optimistic,\n        });\n    }\n    getInitialResult(initialFetchPolicy) {\n        const fetchPolicy = this.queryManager.prioritizeCacheValues ?\n            \"cache-first\"\n            : initialFetchPolicy || this.options.fetchPolicy;\n        const cacheResult = () => {\n            const diff = this.getCacheDiff();\n            // TODO: queryInfo.getDiff should handle this since cache.diff returns a\n            // null when returnPartialData is false\n            const data = this.options.returnPartialData || diff.complete ?\n                diff.result ?? undefined\n                : undefined;\n            return this.maskResult({\n                data,\n                dataState: diff.complete ? \"complete\"\n                    : data === undefined ? \"empty\"\n                        : \"partial\",\n                loading: !diff.complete,\n                networkStatus: diff.complete ? NetworkStatus.ready : NetworkStatus.loading,\n                partial: !diff.complete,\n            });\n        };\n        switch (fetchPolicy) {\n            case \"cache-only\": {\n                return {\n                    ...cacheResult(),\n                    loading: false,\n                    networkStatus: NetworkStatus.ready,\n                };\n            }\n            case \"cache-first\":\n                return cacheResult();\n            case \"cache-and-network\":\n                return {\n                    ...cacheResult(),\n                    loading: true,\n                    networkStatus: NetworkStatus.loading,\n                };\n            case \"standby\":\n                return empty;\n            default:\n                return uninitialized;\n        }\n    }\n    resubscribeCache() {\n        const { variables, fetchPolicy } = this.options;\n        const query = this.query;\n        const shouldUnsubscribe = fetchPolicy === \"standby\" ||\n            fetchPolicy === \"no-cache\" ||\n            this.waitForNetworkResult;\n        const shouldResubscribe = !isEqualQuery({ query, variables }, this.unsubscribeFromCache) &&\n            !this.waitForNetworkResult;\n        if (shouldUnsubscribe || shouldResubscribe) {\n            this.unsubscribeFromCache?.();\n        }\n        if (shouldUnsubscribe || !shouldResubscribe) {\n            return;\n        }\n        const watch = {\n            query,\n            variables,\n            optimistic: true,\n            watcher: this,\n            callback: (diff) => {\n                const info = this.queryManager.getDocumentInfo(query);\n                if (info.hasClientExports || info.hasForcedResolvers) {\n                    // If this is not set to something different than `diff`, we will\n                    // not be notified about future cache changes with an equal `diff`.\n                    // That would be the case if we are working with client-only fields\n                    // that are forced or with `exports` fields that might change, causing\n                    // local resolvers to return a new result.\n                    // This is based on an implementation detail of `InMemoryCache`, which\n                    // is not optimal - but the only alternative to this would be to\n                    // resubscribe to the cache asynchonouly, which would bear the risk of\n                    // missing further synchronous updates.\n                    watch.lastDiff = undefined;\n                }\n                if (watch.lastOwnDiff === diff) {\n                    // skip cache updates that were caused by our own writes\n                    return;\n                }\n                const { result: previousResult } = this.subject.getValue();\n                if (!diff.complete &&\n                    // If we are trying to deliver an incomplete cache result, we avoid\n                    // reporting it if the query has errored, otherwise we let the broadcast try\n                    // and repair the partial result by refetching the query. This check avoids\n                    // a situation where a query that errors and another succeeds with\n                    // overlapping data does not report the partial data result to the errored\n                    // query.\n                    //\n                    // See https://github.com/apollographql/apollo-client/issues/11400 for more\n                    // information on this issue.\n                    (previousResult.error ||\n                        // Prevent to schedule a notify directly after the `ObservableQuery`\n                        // has been `reset` (which will set the `previousResult` to `uninitialized` or `empty`)\n                        // as in those cases, `resetCache` will manually call `refetch` with more intentional timing.\n                        previousResult === uninitialized ||\n                        previousResult === empty)) {\n                    return;\n                }\n                if (!equal(previousResult.data, diff.result)) {\n                    this.scheduleNotify();\n                }\n            },\n        };\n        const cancelWatch = this.queryManager.cache.watch(watch);\n        this.unsubscribeFromCache = Object.assign(() => {\n            this.unsubscribeFromCache = undefined;\n            cancelWatch();\n        }, { query, variables });\n    }\n    stableLastResult;\n    getCurrentResult() {\n        const { result: current } = this.subject.getValue();\n        let value = (\n        // if the `current` result is in an error state, we will always return that\n        // error state, even if we have no observers\n        (current.networkStatus === NetworkStatus.error ||\n            // if we have observers, we are watching the cache and\n            // this.subject.getValue() will always be up to date\n            this.hasObservers() || // if we are using a `no-cache` fetch policy in which case this\n        // `ObservableQuery` cannot have been updated from the outside - in\n        // that case, we prefer to keep the current value\n        this.options.fetchPolicy === \"no-cache\")) ?\n            current\n            // otherwise, the `current` value might be outdated due to missed\n            // external updates - calculate it again\n            : this.getInitialResult();\n        if (value === uninitialized) {\n            value = this.getInitialResult();\n        }\n        if (!equal(this.stableLastResult, value)) {\n            this.stableLastResult = value;\n        }\n        return this.stableLastResult;\n    }\n    /**\n     * Update the variables of this observable query, and fetch the new results.\n     * This method should be preferred over `setVariables` in most use cases.\n     *\n     * Returns a `ResultPromise` with an additional `.retain()` method. Calling\n     * `.retain()` keeps the network operation running even if the `ObservableQuery`\n     * no longer requires the result.\n     *\n     * Note: `refetch()` guarantees that a value will be emitted from the\n     * observable, even if the result is deep equal to the previous value.\n     *\n     * @param variables - The new set of variables. If there are missing variables,\n     * the previous values of those variables will be used.\n     */\n    refetch(variables) {\n        const { fetchPolicy } = this.options;\n        const reobserveOptions = {\n            // Always disable polling for refetches.\n            pollInterval: 0,\n        };\n        // Unless the provided fetchPolicy always consults the network\n        // (no-cache, network-only, or cache-and-network), override it with\n        // network-only to force the refetch for this fetchQuery call.\n        if (fetchPolicy === \"no-cache\") {\n            reobserveOptions.fetchPolicy = \"no-cache\";\n        }\n        else {\n            reobserveOptions.fetchPolicy = \"network-only\";\n        }\n        if (__DEV__ && variables && hasOwnProperty.call(variables, \"variables\")) {\n            const queryDef = getQueryDefinition(this.query);\n            const vars = queryDef.variableDefinitions;\n            if (!vars || !vars.some((v) => v.variable.name.value === \"variables\")) {\n                __DEV__ && invariant.warn(78, variables, queryDef.name?.value || queryDef);\n            }\n        }\n        if (variables && !equal(this.variables, variables)) {\n            // Update the existing options with new variables\n            reobserveOptions.variables = this.options.variables =\n                this.getVariablesWithDefaults({ ...this.variables, ...variables });\n        }\n        this._lastWrite = undefined;\n        return this._reobserve(reobserveOptions, {\n            newNetworkStatus: NetworkStatus.refetch,\n        });\n    }\n    fetchMore({ query, variables, context, errorPolicy, updateQuery, }) {\n        invariant(\n            this.options.fetchPolicy !== \"cache-only\",\n            79,\n            getOperationName(this.query, \"(anonymous)\")\n        );\n        const combinedOptions = {\n            ...compact(this.options, { errorPolicy: \"none\" }, {\n                query,\n                context,\n                errorPolicy,\n            }),\n            variables: (query ? variables : ({\n                ...this.variables,\n                ...variables,\n            })),\n            // The fetchMore request goes immediately to the network and does\n            // not automatically write its result to the cache (hence no-cache\n            // instead of network-only), because we allow the caller of\n            // fetchMore to provide an updateQuery callback that determines how\n            // the data gets written to the cache.\n            fetchPolicy: \"no-cache\",\n            notifyOnNetworkStatusChange: this.options.notifyOnNetworkStatusChange,\n        };\n        combinedOptions.query = this.transformDocument(combinedOptions.query);\n        // If a temporary query is passed to `fetchMore`, we don't want to store\n        // it as the last query result since it may be an optimized query for\n        // pagination. We will however run the transforms on the original document\n        // as well as the document passed in `fetchMoreOptions` to ensure the cache\n        // uses the most up-to-date document which may rely on runtime conditionals.\n        this.lastQuery =\n            query ?\n                this.transformDocument(this.options.query)\n                : combinedOptions.query;\n        let wasUpdated = false;\n        const isCached = this.options.fetchPolicy !== \"no-cache\";\n        if (!isCached) {\n            invariant(updateQuery, 80);\n        }\n        const { finalize, pushNotification } = this.pushOperation(NetworkStatus.fetchMore);\n        pushNotification({\n            source: \"newNetworkStatus\",\n            kind: \"N\",\n            value: {},\n        }, { shouldEmit: 3 /* EmitBehavior.networkStatusChange */ });\n        return this.queryManager\n            .fetchQuery(combinedOptions, NetworkStatus.fetchMore)\n            .then((fetchMoreResult) => {\n            // disable the `fetchMore` override that is currently active\n            // the next updates caused by this should not be `fetchMore` anymore,\n            // but `ready` or whatever other calculated loading state is currently\n            // appropriate\n            finalize();\n            if (isCached) {\n                // Separately getting a diff here before the batch - `onWatchUpdated` might be\n                // called with an `undefined` `lastDiff` on the watcher if the cache was just subscribed to.\n                const lastDiff = this.getCacheDiff();\n                // Performing this cache update inside a cache.batch transaction ensures\n                // any affected cache.watch watchers are notified at most once about any\n                // updates. Most watchers will be using the QueryInfo class, which\n                // responds to notifications by calling reobserveCacheFirst to deliver\n                // fetchMore cache results back to this ObservableQuery.\n                this.queryManager.cache.batch({\n                    update: (cache) => {\n                        if (updateQuery) {\n                            cache.updateQuery({\n                                query: this.query,\n                                variables: this.variables,\n                                returnPartialData: true,\n                                optimistic: false,\n                            }, (previous) => updateQuery(previous, {\n                                fetchMoreResult: fetchMoreResult.data,\n                                variables: combinedOptions.variables,\n                            }));\n                        }\n                        else {\n                            // If we're using a field policy instead of updateQuery, the only\n                            // thing we need to do is write the new data to the cache using\n                            // combinedOptions.variables (instead of this.variables, which is\n                            // what this.updateQuery uses, because it works by abusing the\n                            // original field value, keyed by the original variables).\n                            cache.writeQuery({\n                                query: combinedOptions.query,\n                                variables: combinedOptions.variables,\n                                data: fetchMoreResult.data,\n                            });\n                        }\n                    },\n                    onWatchUpdated: (watch, diff) => {\n                        if (watch.watcher === this &&\n                            !equal(diff.result, lastDiff.result)) {\n                            wasUpdated = true;\n                        }\n                    },\n                });\n            }\n            else {\n                // There is a possibility `lastResult` may not be set when\n                // `fetchMore` is called which would cause this to crash. This should\n                // only happen if we haven't previously reported a result. We don't\n                // quite know what the right behavior should be here since this block\n                // of code runs after the fetch result has executed on the network.\n                // We plan to let it crash in the meantime.\n                //\n                // If we get bug reports due to the `data` property access on\n                // undefined, this should give us a real-world scenario that we can\n                // use to test against and determine the right behavior. If we do end\n                // up changing this behavior, this may require, for example, an\n                // adjustment to the types on `updateQuery` since that function\n                // expects that the first argument always contains previous result\n                // data, but not `undefined`.\n                const lastResult = this.getCurrentResult();\n                const data = updateQuery(lastResult.data, {\n                    fetchMoreResult: fetchMoreResult.data,\n                    variables: combinedOptions.variables,\n                });\n                // was reportResult\n                pushNotification({\n                    kind: \"N\",\n                    value: {\n                        ...lastResult,\n                        networkStatus: NetworkStatus.ready,\n                        // will be overwritten anyways, just here for types sake\n                        loading: false,\n                        data: data,\n                        dataState: lastResult.dataState === \"streaming\" ? \"streaming\" : \"complete\",\n                    },\n                    source: \"network\",\n                });\n            }\n            return this.maskResult(fetchMoreResult);\n        })\n            .finally(() => {\n            // call `finalize` a second time in case the `.then` case above was not reached\n            finalize();\n            // In case the cache writes above did not generate a broadcast\n            // notification (which would have been intercepted by onWatchUpdated),\n            // likely because the written data were the same as what was already in\n            // the cache, we still want fetchMore to deliver its final loading:false\n            // result with the unchanged data.\n            if (isCached && !wasUpdated) {\n                pushNotification({\n                    kind: \"N\",\n                    source: \"newNetworkStatus\",\n                    value: {},\n                }, { shouldEmit: 1 /* EmitBehavior.force */ });\n            }\n        });\n    }\n    // XXX the subscription variables are separate from the query variables.\n    // if you want to update subscription variables, right now you have to do that separately,\n    // and you can only do it by stopping the subscription and then subscribing again with new variables.\n    /**\n     * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.\n     *\n     * This function returns _another_ function that you can call to terminate the subscription.\n     */\n    subscribeToMore(options) {\n        const subscription = this.queryManager\n            .startGraphQLSubscription({\n            query: options.document,\n            variables: options.variables,\n            context: options.context,\n        })\n            .subscribe({\n            next: (subscriptionData) => {\n                const { updateQuery, onError } = options;\n                const { error } = subscriptionData;\n                if (error) {\n                    if (onError) {\n                        onError(error);\n                    }\n                    else {\n                        invariant.error(81, error);\n                    }\n                    return;\n                }\n                if (updateQuery) {\n                    this.updateQuery((previous, updateOptions) => updateQuery(previous, {\n                        subscriptionData: subscriptionData,\n                        ...updateOptions,\n                    }));\n                }\n            },\n        });\n        this.subscriptions.add(subscription);\n        return () => {\n            if (this.subscriptions.delete(subscription)) {\n                subscription.unsubscribe();\n            }\n        };\n    }\n    /**\n    * @internal\n    * \n    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n    */\n    applyOptions(newOptions) {\n        const mergedOptions = compact(this.options, newOptions || {});\n        assign(this.options, mergedOptions);\n        this.updatePolling();\n    }\n    /**\n     * Update the variables of this observable query, and fetch the new results\n     * if they've changed. Most users should prefer `refetch` instead of\n     * `setVariables` in order to to be properly notified of results even when\n     * they come from the cache.\n     *\n     * Note: `setVariables()` guarantees that a value will be emitted from the\n     * observable, even if the result is deeply equal to the previous value.\n     *\n     * Note: the promise will resolve with the last emitted result\n     * when either the variables match the current variables or there\n     * are no subscribers to the query.\n     *\n     * @param variables - The new set of variables. If there are missing variables,\n     * the previous values of those variables will be used.\n     */\n    async setVariables(variables) {\n        variables = this.getVariablesWithDefaults(variables);\n        if (equal(this.variables, variables)) {\n            // If we have no observers, then we don't actually want to make a network\n            // request. As soon as someone observes the query, the request will kick\n            // off. For now, we just store any changes. (See #1077)\n            return toQueryResult(this.getCurrentResult());\n        }\n        this.options.variables = variables;\n        // See comment above\n        if (!this.hasObservers()) {\n            return toQueryResult(this.getCurrentResult());\n        }\n        return this._reobserve({\n            // Reset options.fetchPolicy to its original value.\n            fetchPolicy: this.options.initialFetchPolicy,\n            variables,\n        }, { newNetworkStatus: NetworkStatus.setVariables });\n    }\n    /**\n     * A function that enables you to update the query's cached result without executing a followup GraphQL operation.\n     *\n     * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.\n     */\n    updateQuery(mapFn) {\n        const { queryManager } = this;\n        const { result, complete } = this.getCacheDiff({ optimistic: false });\n        const newResult = mapFn(result, {\n            variables: this.variables,\n            complete: !!complete,\n            previousData: result,\n        });\n        if (newResult) {\n            queryManager.cache.writeQuery({\n                query: this.options.query,\n                data: newResult,\n                variables: this.variables,\n            });\n            queryManager.broadcastQueries();\n        }\n    }\n    /**\n     * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).\n     */\n    startPolling(pollInterval) {\n        this.options.pollInterval = pollInterval;\n        this.updatePolling();\n    }\n    /**\n     * A function that instructs the query to stop polling after a previous call to `startPolling`.\n     */\n    stopPolling() {\n        this.options.pollInterval = 0;\n        this.updatePolling();\n    }\n    // Update options.fetchPolicy according to options.nextFetchPolicy.\n    applyNextFetchPolicy(reason, \n    // It's possible to use this method to apply options.nextFetchPolicy to\n    // options.fetchPolicy even if options !== this.options, though that happens\n    // most often when the options are temporary, used for only one request and\n    // then thrown away, so nextFetchPolicy may not end up mattering.\n    options) {\n        if (options.nextFetchPolicy) {\n            const { fetchPolicy = \"cache-first\", initialFetchPolicy = fetchPolicy } = options;\n            if (fetchPolicy === \"standby\") {\n                // Do nothing, leaving options.fetchPolicy unchanged.\n            }\n            else if (typeof options.nextFetchPolicy === \"function\") {\n                // When someone chooses \"cache-and-network\" or \"network-only\" as their\n                // initial FetchPolicy, they often do not want future cache updates to\n                // trigger unconditional network requests, which is what repeatedly\n                // applying the \"cache-and-network\" or \"network-only\" policies would\n                // seem to imply. Instead, when the cache reports an update after the\n                // initial network request, it may be desirable for subsequent network\n                // requests to be triggered only if the cache result is incomplete. To\n                // that end, the options.nextFetchPolicy option provides an easy way to\n                // update options.fetchPolicy after the initial network request, without\n                // having to call observableQuery.reobserve.\n                options.fetchPolicy = options.nextFetchPolicy.call(options, fetchPolicy, { reason, options, observable: this, initialFetchPolicy });\n            }\n            else if (reason === \"variables-changed\") {\n                options.fetchPolicy = initialFetchPolicy;\n            }\n            else {\n                options.fetchPolicy = options.nextFetchPolicy;\n            }\n        }\n        return options.fetchPolicy;\n    }\n    fetch(options, networkStatus, fetchQuery, operator) {\n        // TODO Make sure we update the networkStatus (and infer fetchVariables)\n        // before actually committing to the fetch.\n        const initialFetchPolicy = this.options.fetchPolicy;\n        options.context ??= {};\n        let synchronouslyEmitted = false;\n        const onCacheHit = () => {\n            synchronouslyEmitted = true;\n        };\n        const fetchQueryOperator = // we cannot use `tap` here, since it allows only for a \"before subscription\"\n         \n        // hook with `subscribe` and we care for \"directly before and after subscription\"\n        (source) => new Observable((subscriber) => {\n            try {\n                return source.subscribe({\n                    next(value) {\n                        synchronouslyEmitted = true;\n                        subscriber.next(value);\n                    },\n                    error: (error) => subscriber.error(error),\n                    complete: () => subscriber.complete(),\n                });\n            }\n            finally {\n                if (!synchronouslyEmitted) {\n                    operation.override = networkStatus;\n                    this.input.next({\n                        kind: \"N\",\n                        source: \"newNetworkStatus\",\n                        value: {\n                            resetError: true,\n                        },\n                        query,\n                        variables,\n                        meta: {\n                            shouldEmit: 3 /* EmitBehavior.networkStatusChange */,\n                            /*\n                             * The moment this notification is emitted, `nextFetchPolicy`\n                             * might already have switched from a `network-only` to a\n                             * `cache-something` policy, so we want to ensure that the\n                             * loading state emit doesn't accidentally read from the cache\n                             * in those cases.\n                             */\n                            fetchPolicy: initialFetchPolicy,\n                        },\n                    });\n                }\n            }\n        });\n        let { observable, fromLink } = this.queryManager.fetchObservableWithInfo(options, {\n            networkStatus,\n            query: fetchQuery,\n            onCacheHit,\n            fetchQueryOperator,\n            observableQuery: this,\n        });\n        // track query and variables from the start of the operation\n        const { query, variables } = this;\n        const operation = {\n            abort: () => {\n                subscription.unsubscribe();\n            },\n            query,\n            variables,\n        };\n        this.activeOperations.add(operation);\n        let forceFirstValueEmit = networkStatus == NetworkStatus.refetch ||\n            networkStatus == NetworkStatus.setVariables;\n        observable = observable.pipe(operator, share());\n        const subscription = observable\n            .pipe(tap({\n            next: (notification) => {\n                if (notification.source === \"newNetworkStatus\" ||\n                    (notification.kind === \"N\" && notification.value.loading)) {\n                    operation.override = networkStatus;\n                }\n                else {\n                    delete operation.override;\n                }\n            },\n            finalize: () => this.activeOperations.delete(operation),\n        }))\n            .subscribe({\n            next: (value) => {\n                const meta = {};\n                if (forceFirstValueEmit &&\n                    value.kind === \"N\" &&\n                    \"loading\" in value.value &&\n                    !value.value.loading) {\n                    forceFirstValueEmit = false;\n                    meta.shouldEmit = 1 /* EmitBehavior.force */;\n                }\n                this.input.next({ ...value, query, variables, meta });\n            },\n        });\n        return { fromLink, subscription, observable };\n    }\n    // Turns polling on or off based on this.options.pollInterval.\n    didWarnCacheOnlyPolling = false;\n    updatePolling() {\n        // Avoid polling in SSR mode\n        if (this.queryManager.ssrMode) {\n            return;\n        }\n        const { pollingInfo, options: { fetchPolicy, pollInterval }, } = this;\n        if (!pollInterval || !this.hasObservers() || fetchPolicy === \"cache-only\") {\n            if (__DEV__) {\n                if (!this.didWarnCacheOnlyPolling &&\n                    pollInterval &&\n                    fetchPolicy === \"cache-only\") {\n                    __DEV__ && invariant.warn(82, getOperationName(this.query, \"(anonymous)\"));\n                    this.didWarnCacheOnlyPolling = true;\n                }\n            }\n            this.cancelPolling();\n            return;\n        }\n        if (pollingInfo?.interval === pollInterval) {\n            return;\n        }\n        const info = pollingInfo || (this.pollingInfo = {});\n        info.interval = pollInterval;\n        const maybeFetch = () => {\n            if (this.pollingInfo) {\n                if (!isNetworkRequestInFlight(this.networkStatus) &&\n                    !this.options.skipPollAttempt?.()) {\n                    this._reobserve({\n                        // Most fetchPolicy options don't make sense to use in a polling context, as\n                        // users wouldn't want to be polling the cache directly. However, network-only and\n                        // no-cache are both useful for when the user wants to control whether or not the\n                        // polled results are written to the cache.\n                        fetchPolicy: this.options.initialFetchPolicy === \"no-cache\" ?\n                            \"no-cache\"\n                            : \"network-only\",\n                    }, {\n                        newNetworkStatus: NetworkStatus.poll,\n                    }).then(poll, poll);\n                }\n                else {\n                    poll();\n                }\n            }\n        };\n        const poll = () => {\n            const info = this.pollingInfo;\n            if (info) {\n                clearTimeout(info.timeout);\n                info.timeout = setTimeout(maybeFetch, info.interval);\n            }\n        };\n        poll();\n    }\n    // This differs from stopPolling in that it does not set pollInterval to 0\n    cancelPolling() {\n        if (this.pollingInfo) {\n            clearTimeout(this.pollingInfo.timeout);\n            delete this.pollingInfo;\n        }\n    }\n    /**\n     * Reevaluate the query, optionally against new options. New options will be\n     * merged with the current options when given.\n     *\n     * Note: `variables` can be reset back to their defaults (typically empty) by calling `reobserve` with\n     * `variables: undefined`.\n     */\n    reobserve(newOptions) {\n        return this._reobserve(newOptions);\n    }\n    _reobserve(newOptions, internalOptions) {\n        this.isTornDown = false;\n        let { newNetworkStatus } = internalOptions || {};\n        this.queryManager.obsQueries.add(this);\n        const useDisposableObservable = \n        // Refetching uses a disposable Observable to allow refetches using different\n        // options, without permanently altering the options of the\n        // original ObservableQuery.\n        newNetworkStatus === NetworkStatus.refetch ||\n            // Polling uses a disposable Observable so the polling options (which force\n            // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n            newNetworkStatus === NetworkStatus.poll;\n        // Save the old variables, since Object.assign may modify them below.\n        const oldVariables = this.variables;\n        const oldFetchPolicy = this.options.fetchPolicy;\n        const mergedOptions = compact(this.options, newOptions || {});\n        // This request will hit the network, so even if there are no variables,\n        // we now know that's intentional. (see #12996)\n        // Even if that happens only once, we want `variablesUnknown` to stay false permanently.\n        this.variablesUnknown &&= mergedOptions.fetchPolicy === \"standby\";\n        const options = useDisposableObservable ?\n            // Disposable Observable fetches receive a shallow copy of this.options\n            // (merged with newOptions), leaving this.options unmodified.\n            mergedOptions\n            : assign(this.options, mergedOptions);\n        // Don't update options.query with the transformed query to avoid\n        // overwriting this.options.query when we aren't using a disposable concast.\n        // We want to ensure we can re-run the custom document transforms the next\n        // time a request is made against the original query.\n        const query = this.transformDocument(options.query);\n        this.lastQuery = query;\n        // Reevaluate variables to allow resetting variables with variables: undefined,\n        // otherwise `compact` will ignore the `variables` key in `newOptions`. We\n        // do this after we run the query transform to ensure we get default\n        // variables from the transformed query.\n        //\n        // Note: updating options.variables may mutate this.options.variables\n        // in the case of a non-disposable query. This is intentional.\n        if (newOptions && \"variables\" in newOptions) {\n            options.variables = this.getVariablesWithDefaults(newOptions.variables);\n        }\n        if (!useDisposableObservable) {\n            // We can skip calling updatePolling if we're not changing this.options.\n            this.updatePolling();\n            // Reset options.fetchPolicy to its original value when variables change,\n            // unless a new fetchPolicy was provided by newOptions.\n            if (newOptions &&\n                newOptions.variables &&\n                !equal(newOptions.variables, oldVariables) &&\n                // Don't mess with the fetchPolicy if it's currently \"standby\".\n                options.fetchPolicy !== \"standby\" &&\n                // If we're changing the fetchPolicy anyway, don't try to change it here\n                // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n                (options.fetchPolicy === oldFetchPolicy ||\n                    // A `nextFetchPolicy` function has even higher priority, though,\n                    // so in that case `applyNextFetchPolicy` must be called.\n                    typeof options.nextFetchPolicy === \"function\")) {\n                // This might mutate options.fetchPolicy\n                this.applyNextFetchPolicy(\"variables-changed\", options);\n                if (newNetworkStatus === void 0) {\n                    newNetworkStatus = NetworkStatus.setVariables;\n                }\n            }\n        }\n        const oldNetworkStatus = this.networkStatus;\n        if (!newNetworkStatus) {\n            newNetworkStatus = NetworkStatus.loading;\n            if (oldNetworkStatus !== NetworkStatus.loading &&\n                newOptions?.variables &&\n                !equal(newOptions.variables, oldVariables)) {\n                newNetworkStatus = NetworkStatus.setVariables;\n            }\n            // QueryManager does not emit any values for standby fetch policies so we\n            // want ensure that the networkStatus remains ready.\n            if (options.fetchPolicy === \"standby\") {\n                newNetworkStatus = NetworkStatus.ready;\n            }\n        }\n        if (options.fetchPolicy === \"standby\") {\n            this.cancelPolling();\n        }\n        this.resubscribeCache();\n        const { promise, operator: promiseOperator } = getTrackingOperatorPromise((value) => {\n            switch (value.kind) {\n                case \"E\":\n                    throw value.error;\n                case \"N\":\n                    if (value.source !== \"newNetworkStatus\" && !value.value.loading)\n                        return value.value;\n            }\n        }, \n        // This default value should only be used when using a `fetchPolicy` of\n        // `standby` since that fetch policy completes without emitting a\n        // result. Since we are converting this to a QueryResult type, we\n        // omit the extra fields from ApolloQueryResult in the default value.\n        options.fetchPolicy === \"standby\" ?\n            { data: undefined }\n            : undefined);\n        const { subscription, observable, fromLink } = this.fetch(options, newNetworkStatus, query, promiseOperator);\n        if (!useDisposableObservable && (fromLink || !this.linkSubscription)) {\n            if (this.linkSubscription) {\n                this.linkSubscription.unsubscribe();\n            }\n            this.linkSubscription = subscription;\n        }\n        const ret = Object.assign(preventUnhandledRejection(promise\n            .then((result) => toQueryResult(this.maskResult(result)))\n            .finally(() => {\n            if (!this.hasObservers() && this.activeOperations.size === 0) {\n                // If `reobserve` was called on a query without any observers,\n                // the teardown logic would never be called, so we need to\n                // call it here to ensure the query is properly torn down.\n                this.tearDownQuery();\n            }\n        })), {\n            retain: () => {\n                const subscription = observable.subscribe({});\n                const unsubscribe = () => subscription.unsubscribe();\n                promise.then(unsubscribe, unsubscribe);\n                return ret;\n            },\n        });\n        return ret;\n    }\n    hasObservers() {\n        return this.subject.observed;\n    }\n    /**\n     * Tears down the `ObservableQuery` and stops all active operations by sending a `complete` notification.\n     */\n    stop() {\n        this.subject.complete();\n        this.initializeObservablesQueue();\n        this.tearDownQuery();\n    }\n    tearDownQuery() {\n        if (this.isTornDown)\n            return;\n        this.resetNotifications();\n        this.unsubscribeFromCache?.();\n        if (this.linkSubscription) {\n            this.linkSubscription.unsubscribe();\n            delete this.linkSubscription;\n        }\n        this.stopPolling();\n        // stop all active GraphQL subscriptions\n        this.subscriptions.forEach((sub) => sub.unsubscribe());\n        this.subscriptions.clear();\n        this.queryManager.obsQueries.delete(this);\n        this.isTornDown = true;\n        this.abortActiveOperations();\n        this._lastWrite = undefined;\n    }\n    transformDocument(document) {\n        return this.queryManager.transform(document);\n    }\n    maskResult(result) {\n        const masked = this.queryManager.maskOperation({\n            document: this.query,\n            data: result.data,\n            fetchPolicy: this.options.fetchPolicy,\n            cause: this,\n        });\n        // Maintain object identity as much as possible\n        return masked === result.data ? result : { ...result, data: masked };\n    }\n    dirty = false;\n    notifyTimeout;\n    /**\n    * @internal\n    * \n    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n    */\n    resetNotifications() {\n        if (this.notifyTimeout) {\n            clearTimeout(this.notifyTimeout);\n            this.notifyTimeout = void 0;\n        }\n        this.dirty = false;\n    }\n    /**\n    * @internal\n    * \n    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n    */\n    scheduleNotify() {\n        if (this.dirty)\n            return;\n        this.dirty = true;\n        if (!this.notifyTimeout) {\n            this.notifyTimeout = setTimeout(() => this.notify(true), 0);\n        }\n    }\n    /**\n    * @internal\n    * \n    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n    */\n    notify(scheduled = false) {\n        if (!scheduled) {\n            // For queries with client exports or forced resolvers, we don't want to\n            // synchronously reobserve the cache on broadcast,\n            // but actually wait for the `scheduleNotify` timeout triggered by the\n            // `cache.watch` callback from `resubscribeCache`.\n            const info = this.queryManager.getDocumentInfo(this.query);\n            if (info.hasClientExports || info.hasForcedResolvers) {\n                return;\n            }\n        }\n        const { dirty } = this;\n        this.resetNotifications();\n        if (dirty &&\n            (this.options.fetchPolicy == \"cache-only\" ||\n                this.options.fetchPolicy == \"cache-and-network\" ||\n                !this.activeOperations.size)) {\n            const diff = this.getCacheDiff();\n            if (\n            // `fromOptimisticTransaction` is not available through the `cache.diff`\n            // code path, so we need to check it this way\n            equal(diff.result, this.getCacheDiff({ optimistic: false }).result)) {\n                //If this diff did not come from an optimistic transaction\n                // make the ObservableQuery \"reobserve\" the latest data\n                // using a temporary fetch policy of \"cache-first\", so complete cache\n                // results have a chance to be delivered without triggering additional\n                // network requests, even when options.fetchPolicy is \"network-only\"\n                // or \"cache-and-network\". All other fetch policies are preserved by\n                // this method, and are handled by calling oq.reobserve(). If this\n                // reobservation is spurious, distinctUntilChanged still has a\n                // chance to catch it before delivery to ObservableQuery subscribers.\n                this.reobserveCacheFirst();\n            }\n            else {\n                // If this diff came from an optimistic transaction, deliver the\n                // current cache data to the ObservableQuery, but don't perform a\n                // reobservation, since oq.reobserveCacheFirst might make a network\n                // request, and we never want to trigger network requests in the\n                // middle of optimistic updates.\n                this.input.next({\n                    kind: \"N\",\n                    value: {\n                        data: diff.result,\n                        dataState: diff.complete ? \"complete\"\n                            : diff.result ? \"partial\"\n                                : \"empty\",\n                        networkStatus: NetworkStatus.ready,\n                        loading: false,\n                        error: undefined,\n                        partial: !diff.complete,\n                    },\n                    source: \"cache\",\n                    query: this.query,\n                    variables: this.variables,\n                    meta: {},\n                });\n            }\n        }\n    }\n    activeOperations = new Set();\n    pushOperation(networkStatus) {\n        let aborted = false;\n        // track query and variables from the start of the operation\n        const { query, variables } = this;\n        const finalize = () => {\n            this.activeOperations.delete(operation);\n        };\n        const operation = {\n            override: networkStatus,\n            abort: () => {\n                aborted = true;\n                finalize();\n            },\n            query,\n            variables,\n        };\n        this.activeOperations.add(operation);\n        return {\n            finalize,\n            pushNotification: (notification, additionalMeta) => {\n                if (!aborted) {\n                    this.input.next({\n                        ...notification,\n                        query,\n                        variables,\n                        meta: { ...additionalMeta },\n                    });\n                }\n            },\n        };\n    }\n    calculateNetworkStatus(baseNetworkStatus) {\n        if (baseNetworkStatus === NetworkStatus.streaming) {\n            return baseNetworkStatus;\n        }\n        // in the future, this could be more complex logic, e.g. \"refetch\" and\n        // \"fetchMore\" having priority over \"polling\" or \"loading\" network statuses\n        // as for now we just take the \"latest\" operation that is still active,\n        // as that lines up best with previous behavior[]\n        const operation = Array.from(this.activeOperations.values())\n            .reverse()\n            .find((operation) => isEqualQuery(operation, this) && operation.override !== undefined);\n        return operation?.override ?? baseNetworkStatus;\n    }\n    abortActiveOperations() {\n        this.activeOperations.forEach((operation) => operation.abort());\n    }\n    /**\n    * @internal\n    * Called from `clearStore`.\n    *\n    * - resets the query to its initial state\n    * - cancels all active operations and their subscriptions\n    * \n    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n    */\n    reset() {\n        // exception for cache-only queries - we reset them into a \"ready\" state\n        // as we won't trigger a refetch for them\n        const resetToEmpty = this.options.fetchPolicy === \"cache-only\";\n        this.setResult(resetToEmpty ? empty : uninitialized, {\n            shouldEmit: resetToEmpty ? 1 /* EmitBehavior.force */ : 2 /* EmitBehavior.never */,\n        });\n        this.abortActiveOperations();\n    }\n    /**\n    * @internal\n    * \n    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n    */\n    setResult(result, additionalMeta) {\n        this.input.next({\n            source: \"setResult\",\n            kind: \"N\",\n            value: result,\n            query: this.query,\n            variables: this.variables,\n            meta: { ...additionalMeta },\n        });\n    }\n    operator = filterMap((notification) => {\n        const { query, variables, meta } = notification;\n        if (notification.source === \"setResult\") {\n            return { query, variables, result: notification.value, meta };\n        }\n        if (notification.kind === \"C\" || !isEqualQuery(notification, this)) {\n            return;\n        }\n        let result;\n        const previous = this.subject.getValue();\n        if (notification.source === \"cache\") {\n            result = notification.value;\n            if (result.networkStatus === NetworkStatus.ready &&\n                result.partial &&\n                (!this.options.returnPartialData ||\n                    previous.result.networkStatus === NetworkStatus.error) &&\n                this.options.fetchPolicy !== \"cache-only\") {\n                return;\n            }\n        }\n        else if (notification.source === \"network\") {\n            if (this.waitForNetworkResult) {\n                this.waitForNetworkResult = false;\n                this.resubscribeCache();\n            }\n            result =\n                notification.kind === \"E\" ?\n                    {\n                        ...(isEqualQuery(previous, notification) ?\n                            previous.result\n                            : { data: undefined, dataState: \"empty\", partial: true }),\n                        error: notification.error,\n                        networkStatus: NetworkStatus.error,\n                        loading: false,\n                    }\n                    : notification.value;\n            if (notification.kind === \"E\" && result.dataState === \"streaming\") {\n                result.dataState = \"complete\";\n            }\n            if (result.error) {\n                meta.shouldEmit = 1 /* EmitBehavior.force */;\n            }\n        }\n        else if (notification.source === \"newNetworkStatus\") {\n            const baseResult = isEqualQuery(previous, notification) ?\n                previous.result\n                : this.getInitialResult(meta.fetchPolicy);\n            const { resetError } = notification.value;\n            const error = resetError ? undefined : baseResult.error;\n            const networkStatus = error ? NetworkStatus.error : NetworkStatus.ready;\n            result = {\n                ...baseResult,\n                error,\n                networkStatus,\n            };\n        }\n        // every code path until here should have either returned or set a result,\n        // but typescript needs a little help\n        invariant(result);\n        // normalize result shape\n        if (!result.error)\n            delete result.error;\n        result.networkStatus = this.calculateNetworkStatus(result.networkStatus);\n        result.loading = isNetworkRequestInFlight(result.networkStatus);\n        result = this.maskResult(result);\n        return { query, variables, result, meta };\n    });\n    // Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n    // delivery of any new data from the cache, possibly falling back to the network\n    // if any cache data are missing. This allows _complete_ cache results to be\n    // delivered without also kicking off unnecessary network requests when\n    // this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n    // this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n    // \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\n    reobserveCacheFirst() {\n        const { fetchPolicy, nextFetchPolicy } = this.options;\n        if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n            this.reobserve({\n                fetchPolicy: \"cache-first\",\n                // Use a temporary nextFetchPolicy function that replaces itself with the\n                // previous nextFetchPolicy value and returns the original fetchPolicy.\n                nextFetchPolicy(currentFetchPolicy, context) {\n                    // Replace this nextFetchPolicy function in the options object with the\n                    // original this.options.nextFetchPolicy value.\n                    this.nextFetchPolicy = nextFetchPolicy;\n                    // If the original nextFetchPolicy value was a function, give it a\n                    // chance to decide what happens here.\n                    if (typeof this.nextFetchPolicy === \"function\") {\n                        return this.nextFetchPolicy(currentFetchPolicy, context);\n                    }\n                    // Otherwise go back to the original this.options.fetchPolicy.\n                    return fetchPolicy;\n                },\n            });\n        }\n        else {\n            this.reobserve();\n        }\n    }\n    getVariablesWithDefaults(variables) {\n        return this.queryManager.getVariables(this.query, variables);\n    }\n}\nexport function logMissingFieldErrors(missing) {\n    if (__DEV__ && missing) {\n        __DEV__ && invariant.debug(83, missing);\n    }\n}\nfunction isEqualQuery(a, b) {\n    return !!(a && b && a.query === b.query && equal(a.variables, b.variables));\n}\nfunction getTrackingOperatorPromise(filterMapCb, defaultValue) {\n    let lastValue = defaultValue, resolve, reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    const operator = tap({\n        next(value) {\n            try {\n                const newValue = filterMapCb(value);\n                if (newValue !== undefined) {\n                    lastValue = newValue;\n                }\n            }\n            catch (error) {\n                reject(error);\n            }\n        },\n        finalize: () => {\n            if (lastValue) {\n                resolve(lastValue);\n            }\n            else {\n                const message = \"The operation was aborted.\";\n                const name = \"AbortError\";\n                reject(typeof DOMException !== \"undefined\" ?\n                    new DOMException(message, name)\n                    // some environments do not have `DOMException`, e.g. node\n                    // uses a normal `Error` with a `name` property instead: https://github.com/phryneas/node/blob/d0579b64f0f6b722f8e49bf8a471dd0d0604a21e/lib/internal/errors.js#L964\n                    // error.code is a legacy property that is not used anymore,\n                    // and also inconsistent across environments (in supporting\n                    // browsers it is `20`, in node `'ABORT_ERR'`) so we omit that.\n                    : Object.assign(new Error(message), { name }));\n            }\n        },\n    });\n    return { promise, operator };\n}\n\n", "import { equal } from \"@wry/equality\";\nimport { getOperationName, graphQLResultHasError, } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nconst IGNORE = {};\nconst destructiveMethodCounts = new WeakMap();\nfunction wrapDestructiveCacheMethod(cache, methodName) {\n    const original = cache[methodName];\n    if (typeof original === \"function\") {\n        // @ts-expect-error this is just too generic to be typed correctly\n        cache[methodName] = function () {\n            destructiveMethodCounts.set(cache, \n            // The %1e15 allows the count to wrap around to 0 safely every\n            // quadrillion evictions, so there's no risk of overflow. To be\n            // clear, this is more of a pedantic principle than something\n            // that matters in any conceivable practical scenario.\n            (destructiveMethodCounts.get(cache) + 1) % 1e15);\n            // @ts-expect-error this is just too generic to be typed correctly\n            return original.apply(this, arguments);\n        };\n    }\n}\nconst queryInfoIds = new WeakMap();\n// A QueryInfo object represents a single network request, either initiated\n// from the QueryManager or from an ObservableQuery.\n// It will only ever be used for a single network call.\n// It is responsible for reporting results to the cache, merging and in a no-cache\n// scenario accumulating the response.\nexport class QueryInfo {\n    // TODO remove soon - this should be able to be handled by cancelling old operations before starting new ones\n    lastRequestId = 1;\n    cache;\n    queryManager;\n    id;\n    observableQuery;\n    incremental;\n    constructor(queryManager, observableQuery) {\n        const cache = (this.cache = queryManager.cache);\n        const id = (queryInfoIds.get(queryManager) || 0) + 1;\n        queryInfoIds.set(queryManager, id);\n        this.id = id + \"\";\n        this.observableQuery = observableQuery;\n        this.queryManager = queryManager;\n        // Track how often cache.evict is called, since we want eviction to\n        // override the feud-stopping logic in the markQueryResult method, by\n        // causing shouldWrite to return true. Wrapping the cache.evict method\n        // is a bit of a hack, but it saves us from having to make eviction\n        // counting an official part of the ApolloCache API.\n        if (!destructiveMethodCounts.has(cache)) {\n            destructiveMethodCounts.set(cache, 0);\n            wrapDestructiveCacheMethod(cache, \"evict\");\n            wrapDestructiveCacheMethod(cache, \"modify\");\n            wrapDestructiveCacheMethod(cache, \"reset\");\n        }\n    }\n    /**\n    * @internal\n    * For feud-preventing behaviour, `lastWrite` should be shared by all `QueryInfo` instances of an `ObservableQuery`.\n    * In the case of a standalone `QueryInfo`, we will keep a local version.\n    * \n    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.\n    */\n    _lastWrite;\n    get lastWrite() {\n        return (this.observableQuery || this)._lastWrite;\n    }\n    set lastWrite(value) {\n        (this.observableQuery || this)._lastWrite = value;\n    }\n    resetLastWrite() {\n        this.lastWrite = void 0;\n    }\n    shouldWrite(result, variables) {\n        const { lastWrite } = this;\n        return !(lastWrite &&\n            // If cache.evict has been called since the last time we wrote this\n            // data into the cache, there's a chance writing this result into\n            // the cache will repair what was evicted.\n            lastWrite.dmCount === destructiveMethodCounts.get(this.cache) &&\n            equal(variables, lastWrite.variables) &&\n            equal(result.data, lastWrite.result.data));\n    }\n    get hasNext() {\n        return this.incremental ? this.incremental.hasNext : false;\n    }\n    maybeHandleIncrementalResult(cacheData, incoming, query) {\n        const { incrementalHandler } = this.queryManager;\n        if (incrementalHandler.isIncrementalResult(incoming)) {\n            this.incremental ||= incrementalHandler.startRequest({\n                query,\n            });\n            return this.incremental.handle(cacheData, incoming);\n        }\n        return incoming;\n    }\n    markQueryResult(incoming, { document: query, variables, errorPolicy, cacheWriteBehavior, }) {\n        const diffOptions = {\n            query,\n            variables,\n            returnPartialData: true,\n            optimistic: true,\n        };\n        // Cancel the pending notify timeout (if it exists) to prevent extraneous network\n        // requests. To allow future notify timeouts, diff and dirty are reset as well.\n        this.observableQuery?.[\"resetNotifications\"]();\n        const skipCache = cacheWriteBehavior === 0 /* CacheWriteBehavior.FORBID */;\n        const lastDiff = skipCache ? undefined : this.cache.diff(diffOptions);\n        let result = this.maybeHandleIncrementalResult(lastDiff?.result, incoming, query);\n        if (skipCache) {\n            return result;\n        }\n        if (shouldWriteResult(result, errorPolicy)) {\n            // Using a transaction here so we have a chance to read the result\n            // back from the cache before the watch callback fires as a result\n            // of writeQuery, so we can store the new diff quietly and ignore\n            // it when we receive it redundantly from the watch callback.\n            this.cache.batch({\n                onWatchUpdated: (\n                // all additional options on ObservableQuery.CacheWatchOptions are\n                // optional so we can use the type here\n                watch, diff) => {\n                    if (watch.watcher === this.observableQuery) {\n                        // see comment on `lastOwnDiff` for explanation\n                        watch.lastOwnDiff = diff;\n                    }\n                },\n                update: (cache) => {\n                    if (this.shouldWrite(result, variables)) {\n                        cache.writeQuery({\n                            query,\n                            data: result.data,\n                            variables,\n                            overwrite: cacheWriteBehavior === 1 /* CacheWriteBehavior.OVERWRITE */,\n                        });\n                        this.lastWrite = {\n                            result,\n                            variables,\n                            dmCount: destructiveMethodCounts.get(this.cache),\n                        };\n                    }\n                    else {\n                        // If result is the same as the last result we received from\n                        // the network (and the variables match too), avoid writing\n                        // result into the cache again. The wisdom of skipping this\n                        // cache write is far from obvious, since any cache write\n                        // could be the one that puts the cache back into a desired\n                        // state, fixing corruption or missing data. However, if we\n                        // always write every network result into the cache, we enable\n                        // feuds between queries competing to update the same data in\n                        // incompatible ways, which can lead to an endless cycle of\n                        // cache broadcasts and useless network requests. As with any\n                        // feud, eventually one side must step back from the brink,\n                        // letting the other side(s) have the last word(s). There may\n                        // be other points where we could break this cycle, such as\n                        // silencing the broadcast for cache.writeQuery (not a good\n                        // idea, since it just delays the feud a bit) or somehow\n                        // avoiding the network request that just happened (also bad,\n                        // because the server could return useful new data). All\n                        // options considered, skipping this cache write seems to be\n                        // the least damaging place to break the cycle, because it\n                        // reflects the intuition that we recently wrote this exact\n                        // result into the cache, so the cache *should* already/still\n                        // contain this data. If some other query has clobbered that\n                        // data in the meantime, that's too bad, but there will be no\n                        // winners if every query blindly reverts to its own version\n                        // of the data. This approach also gives the network a chance\n                        // to return new data, which will be written into the cache as\n                        // usual, notifying only those queries that are directly\n                        // affected by the cache updates, as usual. In the future, an\n                        // even more sophisticated cache could perhaps prevent or\n                        // mitigate the clobbering somehow, but that would make this\n                        // particular cache write even less important, and thus\n                        // skipping it would be even safer than it is today.\n                        if (lastDiff && lastDiff.complete) {\n                            // Reuse data from the last good (complete) diff that we\n                            // received, when possible.\n                            result = { ...result, data: lastDiff.result };\n                            return;\n                        }\n                        // If the previous this.diff was incomplete, fall through to\n                        // re-reading the latest data with cache.diff, below.\n                    }\n                    const diff = cache.diff(diffOptions);\n                    // If we're allowed to write to the cache, and we can read a\n                    // complete result from the cache, update result.data to be the\n                    // result from the cache, rather than the raw network result.\n                    // Set without setDiff to avoid triggering a notify call, since\n                    // we have other ways of notifying for this result.\n                    if (diff.complete) {\n                        result = { ...result, data: diff.result };\n                    }\n                },\n            });\n        }\n        else {\n            this.lastWrite = void 0;\n        }\n        return result;\n    }\n    markMutationResult(incoming, mutation, cache = this.cache) {\n        const cacheWrites = [];\n        const skipCache = mutation.cacheWriteBehavior === 0 /* CacheWriteBehavior.FORBID */;\n        let result = this.maybeHandleIncrementalResult(skipCache ? undefined : (cache.diff({\n            id: \"ROOT_MUTATION\",\n            // The cache complains if passed a mutation where it expects a\n            // query, so we transform mutations and subscriptions to queries\n            // (only once, thanks to this.transformCache).\n            query: this.queryManager.getDocumentInfo(mutation.document).asQuery,\n            variables: mutation.variables,\n            optimistic: false,\n            returnPartialData: true,\n        }).result), incoming, mutation.document);\n        if (mutation.errorPolicy === \"ignore\") {\n            result = { ...result, errors: [] };\n        }\n        if (graphQLResultHasError(result) && mutation.errorPolicy === \"none\") {\n            return Promise.resolve(result);\n        }\n        const getResultWithDataState = () => ({\n            ...result,\n            dataState: this.hasNext ? \"streaming\" : \"complete\",\n        });\n        if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n            cacheWrites.push({\n                result: result.data,\n                dataId: \"ROOT_MUTATION\",\n                query: mutation.document,\n                variables: mutation.variables,\n            });\n            const { updateQueries } = mutation;\n            if (updateQueries) {\n                this.queryManager\n                    .getObservableQueries(\"all\")\n                    .forEach((observableQuery) => {\n                    const queryName = observableQuery && observableQuery.queryName;\n                    if (!queryName ||\n                        !Object.hasOwnProperty.call(updateQueries, queryName)) {\n                        return;\n                    }\n                    const updater = updateQueries[queryName];\n                    const { query: document, variables } = observableQuery;\n                    // Read the current query result from the store.\n                    const { result: currentQueryResult, complete } = observableQuery.getCacheDiff({ optimistic: false });\n                    if (complete && currentQueryResult) {\n                        // Run our reducer using the current query result and the mutation result.\n                        const nextQueryResult = updater(currentQueryResult, {\n                            mutationResult: getResultWithDataState(),\n                            queryName: (document && getOperationName(document)) || void 0,\n                            queryVariables: variables,\n                        });\n                        // Write the modified result back into the store if we got a new result.\n                        if (nextQueryResult) {\n                            cacheWrites.push({\n                                result: nextQueryResult,\n                                dataId: \"ROOT_QUERY\",\n                                query: document,\n                                variables,\n                            });\n                        }\n                    }\n                });\n            }\n        }\n        let refetchQueries = mutation.refetchQueries;\n        if (typeof refetchQueries === \"function\") {\n            refetchQueries = refetchQueries(getResultWithDataState());\n        }\n        if (cacheWrites.length > 0 ||\n            (refetchQueries || \"\").length > 0 ||\n            mutation.update ||\n            mutation.onQueryUpdated ||\n            mutation.removeOptimistic) {\n            const results = [];\n            this.queryManager\n                .refetchQueries({\n                updateCache: (cache) => {\n                    if (!skipCache) {\n                        cacheWrites.forEach((write) => cache.write(write));\n                    }\n                    // If the mutation has some writes associated with it then we need to\n                    // apply those writes to the store by running this reducer again with\n                    // a write action.\n                    const { update } = mutation;\n                    // Determine whether result is a SingleExecutionResult,\n                    // or the final ExecutionPatchResult.\n                    if (update) {\n                        if (!skipCache) {\n                            // Re-read the ROOT_MUTATION data we just wrote into the cache\n                            // (the first cache.write call in the cacheWrites.forEach loop\n                            // above), so field read functions have a chance to run for\n                            // fields within mutation result objects.\n                            const diff = cache.diff({\n                                id: \"ROOT_MUTATION\",\n                                // The cache complains if passed a mutation where it expects a\n                                // query, so we transform mutations and subscriptions to queries\n                                // (only once, thanks to this.transformCache).\n                                query: this.queryManager.getDocumentInfo(mutation.document)\n                                    .asQuery,\n                                variables: mutation.variables,\n                                optimistic: false,\n                                returnPartialData: true,\n                            });\n                            if (diff.complete) {\n                                result = {\n                                    ...result,\n                                    data: diff.result,\n                                };\n                            }\n                        }\n                        // If we've received the whole response, call the update function.\n                        if (!this.hasNext) {\n                            update(cache, result, {\n                                context: mutation.context,\n                                variables: mutation.variables,\n                            });\n                        }\n                    }\n                    // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n                    // shallow to allow rolling back optimistic evictions.\n                    if (!skipCache && !mutation.keepRootFields && !this.hasNext) {\n                        cache.modify({\n                            id: \"ROOT_MUTATION\",\n                            fields(value, { fieldName, DELETE }) {\n                                return fieldName === \"__typename\" ? value : DELETE;\n                            },\n                        });\n                    }\n                },\n                include: refetchQueries,\n                // Write the final mutation.result to the root layer of the cache.\n                optimistic: false,\n                // Remove the corresponding optimistic layer at the same time as we\n                // write the final non-optimistic result.\n                removeOptimistic: mutation.removeOptimistic,\n                // Let the caller of client.mutate optionally determine the refetching\n                // behavior for watched queries after the mutation.update function runs.\n                // If no onQueryUpdated function was provided for this mutation, pass\n                // null instead of undefined to disable the default refetching behavior.\n                onQueryUpdated: mutation.onQueryUpdated || null,\n            })\n                .forEach((result) => results.push(result));\n            if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n                // Returning a promise here makes the mutation await that promise, so we\n                // include results in that promise's work if awaitRefetchQueries or an\n                // onQueryUpdated function was specified.\n                return Promise.all(results).then(() => result);\n            }\n        }\n        return Promise.resolve(result);\n    }\n    markMutationOptimistic(optimisticResponse, mutation) {\n        const data = typeof optimisticResponse === \"function\" ?\n            optimisticResponse(mutation.variables, { IGNORE })\n            : optimisticResponse;\n        if (data === IGNORE) {\n            return false;\n        }\n        this.cache.recordOptimisticTransaction((cache) => {\n            try {\n                this.markMutationResult({ data }, mutation, cache);\n            }\n            catch (error) {\n                invariant.error(error);\n            }\n        }, this.id);\n        return true;\n    }\n    markSubscriptionResult(result, { document, variables, errorPolicy, cacheWriteBehavior, }) {\n        if (cacheWriteBehavior !== 0 /* CacheWriteBehavior.FORBID */) {\n            if (shouldWriteResult(result, errorPolicy)) {\n                this.cache.write({\n                    query: document,\n                    result: result.data,\n                    dataId: \"ROOT_SUBSCRIPTION\",\n                    variables: variables,\n                });\n            }\n            this.queryManager.broadcastQueries();\n        }\n    }\n}\nfunction shouldWriteResult(result, errorPolicy = \"none\") {\n    const ignoreErrors = errorPolicy === \"ignore\" || errorPolicy === \"all\";\n    let writeWithErrors = !graphQLResultHasError(result);\n    if (!writeWithErrors && ignoreErrors && result.data) {\n        writeWithErrors = true;\n    }\n    return writeWithErrors;\n}\n\n", "import { Trie } from \"@wry/trie\";\nimport { BREAK, Kind, OperationTypeNode, visit } from \"graphql\";\nimport { Observable, throwError } from \"rxjs\";\nimport { catchError, concat, EMPTY, filter, finalize, from, lastValueFrom, map, materialize, mergeMap, of, share, shareReplay, Subject, tap, } from \"rxjs\";\nimport { canonicalStringify } from \"@apollo/client/cache\";\nimport { CombinedGraphQLErrors, graphQLResultHasProtocolErrors, registerLinkError, toErrorLike, } from \"@apollo/client/errors\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"@apollo/client/errors\";\nimport { execute } from \"@apollo/client/link\";\nimport { maskFragment, maskOperation } from \"@apollo/client/masking\";\nimport { cacheSizes, DocumentTransform, isNetworkRequestInFlight, print, } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { AutoCleanedWeakCache, checkDocument, filterMap, getDefaultValues, getOperationDefinition, getOperationName, graphQLResultHasError, hasDirectives, hasForcedResolvers, isDocumentNode, isNonNullObject, makeUniqueId, removeDirectivesFromDocument, toQueryResult, } from \"@apollo/client/utilities/internal\";\nimport { invariant, newInvariantError, } from \"@apollo/client/utilities/invariant\";\nimport { NetworkStatus } from \"./networkStatus.js\";\nimport { logMissingFieldErrors, ObservableQuery } from \"./ObservableQuery.js\";\nimport { QueryInfo } from \"./QueryInfo.js\";\nexport class QueryManager {\n    defaultOptions;\n    client;\n    /**\n     * The options that were passed to the ApolloClient constructor.\n     */\n    clientOptions;\n    assumeImmutableResults;\n    documentTransform;\n    ssrMode;\n    defaultContext;\n    dataMasking;\n    incrementalHandler;\n    localState;\n    queryDeduplication;\n    /**\n     * Whether to prioritize cache values over network results when\n     * `fetchObservableWithInfo` is called.\n     * This will essentially turn a `\"network-only\"` or `\"cache-and-network\"`\n     * fetchPolicy into a `\"cache-first\"` fetchPolicy, but without influencing\n     * the `fetchPolicy` of the `ObservableQuery`.\n     *\n     * This can e.g. be used to prioritize the cache during the first render after\n     * SSR.\n     */\n    prioritizeCacheValues = false;\n    onBroadcast;\n    mutationStore;\n    /**\n     * All ObservableQueries that currently have at least one subscriber.\n     */\n    obsQueries = new Set();\n    // Maps from queryInfo.id strings to Promise rejection functions for\n    // currently active queries and fetches.\n    // Use protected instead of private field so\n    // @apollo/experimental-nextjs-app-support can access type info.\n    fetchCancelFns = new Map();\n    constructor(options) {\n        const defaultDocumentTransform = new DocumentTransform((document) => this.cache.transformDocument(document), \n        // Allow the apollo cache to manage its own transform caches\n        { cache: false });\n        this.client = options.client;\n        this.defaultOptions = options.defaultOptions;\n        this.queryDeduplication = options.queryDeduplication;\n        this.clientOptions = options.clientOptions;\n        this.ssrMode = options.ssrMode;\n        this.assumeImmutableResults = options.assumeImmutableResults;\n        this.dataMasking = options.dataMasking;\n        this.localState = options.localState;\n        this.incrementalHandler = options.incrementalHandler;\n        const documentTransform = options.documentTransform;\n        this.documentTransform =\n            documentTransform ?\n                defaultDocumentTransform\n                    .concat(documentTransform)\n                    // The custom document transform may add new fragment spreads or new\n                    // field selections, so we want to give the cache a chance to run\n                    // again. For example, the InMemoryCache adds __typename to field\n                    // selections and fragments from the fragment registry.\n                    .concat(defaultDocumentTransform)\n                : defaultDocumentTransform;\n        this.defaultContext = options.defaultContext || {};\n        if ((this.onBroadcast = options.onBroadcast)) {\n            this.mutationStore = {};\n        }\n    }\n    get link() {\n        return this.client.link;\n    }\n    get cache() {\n        return this.client.cache;\n    }\n    /**\n     * Call this method to terminate any active query processes, making it safe\n     * to dispose of this QueryManager instance.\n     */\n    stop() {\n        this.obsQueries.forEach((oq) => oq.stop());\n        this.cancelPendingFetches(newInvariantError(84));\n    }\n    cancelPendingFetches(error) {\n        this.fetchCancelFns.forEach((cancel) => cancel(error));\n        this.fetchCancelFns.clear();\n    }\n    async mutate({ mutation, variables, optimisticResponse, updateQueries, refetchQueries = [], awaitRefetchQueries = false, update: updateWithProxyFn, onQueryUpdated, fetchPolicy, errorPolicy, keepRootFields, context, }) {\n        const queryInfo = new QueryInfo(this);\n        mutation = this.cache.transformForLink(this.transform(mutation));\n        const { hasClientExports } = this.getDocumentInfo(mutation);\n        variables = this.getVariables(mutation, variables);\n        if (hasClientExports) {\n            if (__DEV__) {\n                invariant(this.localState, 85, getOperationName(mutation, \"(anonymous)\"));\n            }\n            variables = await this.localState.getExportedVariables({\n                client: this.client,\n                document: mutation,\n                variables,\n                context,\n            });\n        }\n        const mutationStoreValue = this.mutationStore &&\n            (this.mutationStore[queryInfo.id] = {\n                mutation,\n                variables,\n                loading: true,\n                error: null,\n            });\n        const isOptimistic = optimisticResponse &&\n            queryInfo.markMutationOptimistic(optimisticResponse, {\n                document: mutation,\n                variables,\n                cacheWriteBehavior: fetchPolicy === \"no-cache\" ?\n                    0 /* CacheWriteBehavior.FORBID */\n                    : 2 /* CacheWriteBehavior.MERGE */,\n                errorPolicy,\n                context,\n                updateQueries,\n                update: updateWithProxyFn,\n                keepRootFields,\n            });\n        this.broadcastQueries();\n        return new Promise((resolve, reject) => {\n            const cause = {};\n            return this.getObservableFromLink(mutation, {\n                ...context,\n                optimisticResponse: isOptimistic ? optimisticResponse : void 0,\n            }, variables, {}, false)\n                .observable.pipe(validateDidEmitValue(), mergeMap((result) => {\n                const storeResult = { ...result };\n                return from(queryInfo.markMutationResult(storeResult, {\n                    document: mutation,\n                    variables,\n                    cacheWriteBehavior: fetchPolicy === \"no-cache\" ?\n                        0 /* CacheWriteBehavior.FORBID */\n                        : 2 /* CacheWriteBehavior.MERGE */,\n                    errorPolicy,\n                    context,\n                    update: updateWithProxyFn,\n                    updateQueries,\n                    awaitRefetchQueries,\n                    refetchQueries,\n                    removeOptimistic: isOptimistic ? queryInfo.id : void 0,\n                    onQueryUpdated,\n                    keepRootFields,\n                }));\n            }))\n                .pipe(map((storeResult) => {\n                const hasErrors = graphQLResultHasError(storeResult);\n                if (hasErrors && errorPolicy === \"none\") {\n                    throw new CombinedGraphQLErrors(storeResult);\n                }\n                if (mutationStoreValue) {\n                    mutationStoreValue.loading = false;\n                    mutationStoreValue.error = null;\n                }\n                return storeResult;\n            }))\n                .subscribe({\n                next: (storeResult) => {\n                    this.broadcastQueries();\n                    // Since mutations might receive multiple payloads from the\n                    // ApolloLink chain (e.g. when used with @defer),\n                    // we resolve with a SingleExecutionResult or after the final\n                    // ExecutionPatchResult has arrived and we have assembled the\n                    // multipart response into a single result.\n                    if (!queryInfo.hasNext) {\n                        const result = {\n                            data: this.maskOperation({\n                                document: mutation,\n                                data: storeResult.data,\n                                fetchPolicy,\n                                cause,\n                            }),\n                        };\n                        if (graphQLResultHasError(storeResult)) {\n                            result.error = new CombinedGraphQLErrors(storeResult);\n                        }\n                        if (Object.keys(storeResult.extensions || {}).length) {\n                            result.extensions = storeResult.extensions;\n                        }\n                        resolve(result);\n                    }\n                },\n                error: (error) => {\n                    if (mutationStoreValue) {\n                        mutationStoreValue.loading = false;\n                        mutationStoreValue.error = error;\n                    }\n                    if (isOptimistic) {\n                        this.cache.removeOptimistic(queryInfo.id);\n                    }\n                    this.broadcastQueries();\n                    if (errorPolicy === \"ignore\") {\n                        return resolve({ data: undefined });\n                    }\n                    if (errorPolicy === \"all\") {\n                        return resolve({ data: undefined, error });\n                    }\n                    reject(error);\n                },\n            });\n        });\n    }\n    fetchQuery(options, networkStatus) {\n        checkDocument(options.query, OperationTypeNode.QUERY);\n        // do the rest asynchronously to keep the same rejection timing as\n        // checks further in `.mutate`\n        return (async () => lastValueFrom(this.fetchObservableWithInfo(options, {\n            networkStatus,\n        }).observable.pipe(filterMap((value) => {\n            switch (value.kind) {\n                case \"E\":\n                    throw value.error;\n                case \"N\": {\n                    if (value.source !== \"newNetworkStatus\")\n                        return toQueryResult(value.value);\n                }\n            }\n        })), {\n            // This default is needed when a `standby` fetch policy is used to avoid\n            // an EmptyError from rejecting this promise.\n            defaultValue: { data: undefined },\n        }))();\n    }\n    transform(document) {\n        return this.documentTransform.transformDocument(document);\n    }\n    transformCache = new AutoCleanedWeakCache(cacheSizes[\"queryManager.getDocumentInfo\"] ||\n        2000 /* defaultCacheSizes[\"queryManager.getDocumentInfo\"] */);\n    getDocumentInfo(document) {\n        const { transformCache } = this;\n        if (!transformCache.has(document)) {\n            const operationDefinition = getOperationDefinition(document);\n            const cacheEntry = {\n                // TODO These three calls (hasClientExports, shouldForceResolvers, and\n                // usesNonreactiveDirective) are performing independent full traversals\n                // of the transformed document. We should consider merging these\n                // traversals into a single pass in the future, though the work is\n                // cached after the first time.\n                hasClientExports: hasDirectives([\"client\", \"export\"], document, true),\n                hasForcedResolvers: hasForcedResolvers(document),\n                hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n                hasIncrementalDirective: hasDirectives([\"defer\"], document),\n                nonReactiveQuery: addNonReactiveToNamedFragments(document),\n                clientQuery: hasDirectives([\"client\"], document) ? document : null,\n                serverQuery: removeDirectivesFromDocument([\n                    { name: \"client\", remove: true },\n                    { name: \"connection\" },\n                    { name: \"nonreactive\" },\n                    { name: \"unmask\" },\n                ], document),\n                operationType: operationDefinition?.operation,\n                defaultVars: getDefaultValues(operationDefinition),\n                // Transform any mutation or subscription operations to query operations\n                // so we can read/write them from/to the cache.\n                asQuery: {\n                    ...document,\n                    definitions: document.definitions.map((def) => {\n                        if (def.kind === \"OperationDefinition\" &&\n                            def.operation !== \"query\") {\n                            return { ...def, operation: \"query\" };\n                        }\n                        return def;\n                    }),\n                },\n            };\n            transformCache.set(document, cacheEntry);\n        }\n        const entry = transformCache.get(document);\n        if (entry.violation) {\n            throw entry.violation;\n        }\n        return entry;\n    }\n    getVariables(document, variables) {\n        const defaultVars = this.getDocumentInfo(document).defaultVars;\n        const varsWithDefaults = Object.entries(variables ?? {}).map(([key, value]) => [key, value === undefined ? defaultVars[key] : value]);\n        return {\n            ...defaultVars,\n            ...Object.fromEntries(varsWithDefaults),\n        };\n    }\n    watchQuery(options) {\n        checkDocument(options.query, OperationTypeNode.QUERY);\n        const query = this.transform(options.query);\n        // assign variable default values if supplied\n        // NOTE: We don't modify options.query here with the transformed query to\n        // ensure observable.options.query is set to the raw untransformed query.\n        options = {\n            ...options,\n            variables: this.getVariables(query, options.variables),\n        };\n        if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n            options.notifyOnNetworkStatusChange = true;\n        }\n        const observable = new ObservableQuery({\n            queryManager: this,\n            options,\n            transformedQuery: query,\n        });\n        return observable;\n    }\n    query(options) {\n        const query = this.transform(options.query);\n        return this.fetchQuery({\n            ...options,\n            query,\n        }).then((value) => ({\n            ...value,\n            data: this.maskOperation({\n                document: query,\n                data: value?.data,\n                fetchPolicy: options.fetchPolicy,\n            }),\n        }));\n    }\n    requestIdCounter = 1;\n    generateRequestId() {\n        return this.requestIdCounter++;\n    }\n    clearStore(options = {\n        discardWatches: true,\n    }) {\n        // Before we have sent the reset action to the store, we can no longer\n        // rely on the results returned by in-flight requests since these may\n        // depend on values that previously existed in the data portion of the\n        // store. So, we cancel the promises and observers that we have issued\n        // so far and not yet resolved (in the case of queries).\n        this.cancelPendingFetches(newInvariantError(86));\n        this.obsQueries.forEach((observableQuery) => {\n            // Set loading to true so listeners don't trigger unless they want\n            // results with partial data.\n            observableQuery.reset();\n        });\n        if (this.mutationStore) {\n            this.mutationStore = {};\n        }\n        // begin removing data from the store\n        return this.cache.reset(options);\n    }\n    getObservableQueries(include = \"active\") {\n        const queries = new Set();\n        const queryNames = new Map();\n        const queryNamesAndQueryStrings = new Map();\n        const legacyQueryOptions = new Set();\n        if (Array.isArray(include)) {\n            include.forEach((desc) => {\n                if (typeof desc === \"string\") {\n                    queryNames.set(desc, desc);\n                    queryNamesAndQueryStrings.set(desc, false);\n                }\n                else if (isDocumentNode(desc)) {\n                    const queryString = print(this.transform(desc));\n                    queryNames.set(queryString, getOperationName(desc));\n                    queryNamesAndQueryStrings.set(queryString, false);\n                }\n                else if (isNonNullObject(desc) && desc.query) {\n                    legacyQueryOptions.add(desc);\n                }\n            });\n        }\n        this.obsQueries.forEach((oq) => {\n            const document = print(this.transform(oq.options.query));\n            if (include === \"all\") {\n                queries.add(oq);\n                return;\n            }\n            const { queryName, options: { fetchPolicy }, } = oq;\n            if (include === \"active\" && fetchPolicy === \"standby\") {\n                return;\n            }\n            if (include === \"active\" ||\n                (queryName && queryNamesAndQueryStrings.has(queryName)) ||\n                (document && queryNamesAndQueryStrings.has(document))) {\n                queries.add(oq);\n                if (queryName)\n                    queryNamesAndQueryStrings.set(queryName, true);\n                if (document)\n                    queryNamesAndQueryStrings.set(document, true);\n            }\n        });\n        if (legacyQueryOptions.size) {\n            legacyQueryOptions.forEach((options) => {\n                const oq = new ObservableQuery({\n                    queryManager: this,\n                    options: {\n                        ...options,\n                        fetchPolicy: \"network-only\",\n                    },\n                });\n                queries.add(oq);\n            });\n        }\n        if (__DEV__ && queryNamesAndQueryStrings.size) {\n            queryNamesAndQueryStrings.forEach((included, nameOrQueryString) => {\n                if (!included) {\n                    const queryName = queryNames.get(nameOrQueryString);\n                    if (queryName) {\n                        __DEV__ && invariant.warn(87, queryName);\n                    }\n                    else {\n                        __DEV__ && invariant.warn(88);\n                    }\n                }\n            });\n        }\n        return queries;\n    }\n    refetchObservableQueries(includeStandby = false) {\n        const observableQueryPromises = [];\n        this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach((observableQuery) => {\n            const { fetchPolicy } = observableQuery.options;\n            if ((includeStandby || fetchPolicy !== \"standby\") &&\n                fetchPolicy !== \"cache-only\") {\n                observableQueryPromises.push(observableQuery.refetch());\n            }\n        });\n        this.broadcastQueries();\n        return Promise.all(observableQueryPromises);\n    }\n    startGraphQLSubscription(options) {\n        let { query, variables } = options;\n        const { fetchPolicy, errorPolicy = \"none\", context = {}, extensions = {}, } = options;\n        checkDocument(query, OperationTypeNode.SUBSCRIPTION);\n        query = this.transform(query);\n        variables = this.getVariables(query, variables);\n        let restart;\n        if (__DEV__) {\n            invariant(\n                !this.getDocumentInfo(query).hasClientExports || this.localState,\n                89,\n                getOperationName(query, \"(anonymous)\")\n            );\n        }\n        const observable = (this.getDocumentInfo(query).hasClientExports ?\n            from(this.localState.getExportedVariables({\n                client: this.client,\n                document: query,\n                variables,\n                context,\n            }))\n            : of(variables)).pipe(mergeMap((variables) => {\n            const { observable, restart: res } = this.getObservableFromLink(query, context, variables, extensions);\n            const queryInfo = new QueryInfo(this);\n            restart = res;\n            return observable.pipe(map((rawResult) => {\n                queryInfo.markSubscriptionResult(rawResult, {\n                    document: query,\n                    variables,\n                    errorPolicy,\n                    cacheWriteBehavior: fetchPolicy === \"no-cache\" ?\n                        0 /* CacheWriteBehavior.FORBID */\n                        : 2 /* CacheWriteBehavior.MERGE */,\n                });\n                const result = {\n                    data: rawResult.data ?? undefined,\n                };\n                if (graphQLResultHasError(rawResult)) {\n                    result.error = new CombinedGraphQLErrors(rawResult);\n                }\n                else if (graphQLResultHasProtocolErrors(rawResult)) {\n                    result.error = rawResult.extensions[PROTOCOL_ERRORS_SYMBOL];\n                    // Don't emit protocol errors added by HttpLink\n                    delete rawResult.extensions[PROTOCOL_ERRORS_SYMBOL];\n                }\n                if (rawResult.extensions &&\n                    Object.keys(rawResult.extensions).length) {\n                    result.extensions = rawResult.extensions;\n                }\n                if (result.error && errorPolicy === \"none\") {\n                    result.data = undefined;\n                }\n                if (errorPolicy === \"ignore\") {\n                    delete result.error;\n                }\n                return result;\n            }), catchError((error) => {\n                if (errorPolicy === \"ignore\") {\n                    return of({\n                        data: undefined,\n                    });\n                }\n                return of({ data: undefined, error });\n            }), filter((result) => !!(result.data || result.error)));\n        }));\n        return Object.assign(observable, { restart: () => restart?.() });\n    }\n    broadcastQueries() {\n        if (this.onBroadcast)\n            this.onBroadcast();\n        this.obsQueries.forEach((observableQuery) => observableQuery.notify());\n    }\n    // Use protected instead of private field so\n    // @apollo/experimental-nextjs-app-support can access type info.\n    inFlightLinkObservables = new Trie(false);\n    getObservableFromLink(query, context, variables, extensions, \n    // Prefer context.queryDeduplication if specified.\n    deduplication = context?.queryDeduplication ??\n        this.queryDeduplication) {\n        let entry = {};\n        const { serverQuery, clientQuery, operationType, hasIncrementalDirective } = this.getDocumentInfo(query);\n        const operationName = getOperationName(query);\n        const executeContext = {\n            client: this.client,\n        };\n        if (serverQuery) {\n            const { inFlightLinkObservables, link } = this;\n            try {\n                const operation = this.incrementalHandler.prepareRequest({\n                    query: serverQuery,\n                    variables,\n                    context: {\n                        ...this.defaultContext,\n                        ...context,\n                        queryDeduplication: deduplication,\n                    },\n                    extensions,\n                });\n                context = operation.context;\n                function withRestart(source) {\n                    return new Observable((observer) => {\n                        function subscribe() {\n                            return source.subscribe({\n                                next: observer.next.bind(observer),\n                                complete: observer.complete.bind(observer),\n                                error: observer.error.bind(observer),\n                            });\n                        }\n                        let subscription = subscribe();\n                        entry.restart ||= () => {\n                            subscription.unsubscribe();\n                            subscription = subscribe();\n                        };\n                        return () => {\n                            subscription.unsubscribe();\n                            entry.restart = undefined;\n                        };\n                    });\n                }\n                if (deduplication) {\n                    const printedServerQuery = print(serverQuery);\n                    const varJson = canonicalStringify(variables);\n                    entry = inFlightLinkObservables.lookup(printedServerQuery, varJson);\n                    if (!entry.observable) {\n                        entry.observable = execute(link, operation, executeContext).pipe(withRestart, finalize(() => {\n                            if (inFlightLinkObservables.peek(printedServerQuery, varJson) ===\n                                entry) {\n                                inFlightLinkObservables.remove(printedServerQuery, varJson);\n                            }\n                        }), \n                        // We don't want to replay the last emitted value for\n                        // subscriptions and instead opt to wait to receive updates until\n                        // the subscription emits new values.\n                        operationType === OperationTypeNode.SUBSCRIPTION ?\n                            share()\n                            : shareReplay({ refCount: true }));\n                    }\n                }\n                else {\n                    entry.observable = execute(link, operation, executeContext).pipe(withRestart);\n                }\n            }\n            catch (error) {\n                entry.observable = throwError(() => error);\n            }\n        }\n        else {\n            entry.observable = of({ data: {} });\n        }\n        if (clientQuery) {\n            const { operation } = getOperationDefinition(query);\n            if (__DEV__) {\n                invariant(\n                    this.localState,\n                    90,\n                    operation[0].toUpperCase() + operation.slice(1),\n                    operationName ?? \"(anonymous)\"\n                );\n            }\n            invariant(\n                !hasIncrementalDirective,\n                91,\n                operation[0].toUpperCase() + operation.slice(1),\n                operationName ?? \"(anonymous)\"\n            );\n            entry.observable = entry.observable.pipe(mergeMap((result) => {\n                return from(this.localState.execute({\n                    client: this.client,\n                    document: clientQuery,\n                    remoteResult: result,\n                    context,\n                    variables,\n                }));\n            }));\n        }\n        return {\n            restart: () => entry.restart?.(),\n            observable: entry.observable.pipe(catchError((error) => {\n                error = toErrorLike(error);\n                registerLinkError(error);\n                throw error;\n            })),\n        };\n    }\n    getResultsFromLink(options, { queryInfo, cacheWriteBehavior, observableQuery, }) {\n        const requestId = (queryInfo.lastRequestId = this.generateRequestId());\n        const { errorPolicy } = options;\n        // Performing transformForLink here gives this.cache a chance to fill in\n        // missing fragment definitions (for example) before sending this document\n        // through the link chain.\n        const linkDocument = this.cache.transformForLink(options.query);\n        return this.getObservableFromLink(linkDocument, options.context, options.variables).observable.pipe(map((incoming) => {\n            // Use linkDocument rather than queryInfo.document so the\n            // operation/fragments used to write the result are the same as the\n            // ones used to obtain it from the link.\n            const result = queryInfo.markQueryResult(incoming, {\n                ...options,\n                document: linkDocument,\n                cacheWriteBehavior,\n            });\n            const hasErrors = graphQLResultHasError(result);\n            if (hasErrors && errorPolicy === \"none\") {\n                queryInfo.resetLastWrite();\n                observableQuery?.[\"resetNotifications\"]();\n                throw new CombinedGraphQLErrors(result);\n            }\n            const aqr = {\n                data: result.data,\n                ...(queryInfo.hasNext ?\n                    {\n                        loading: true,\n                        networkStatus: NetworkStatus.streaming,\n                        dataState: \"streaming\",\n                        partial: true,\n                    }\n                    : {\n                        dataState: result.data ? \"complete\" : \"empty\",\n                        loading: false,\n                        networkStatus: NetworkStatus.ready,\n                        partial: !result.data,\n                    }),\n            };\n            // In the case we start multiple network requests simultaneously, we\n            // want to ensure we properly set `data` if we're reporting on an old\n            // result which will not be caught by the conditional above that ends up\n            // throwing the markError result.\n            if (hasErrors) {\n                if (errorPolicy === \"none\") {\n                    aqr.data = void 0;\n                    aqr.dataState = \"empty\";\n                }\n                if (errorPolicy !== \"ignore\") {\n                    aqr.error = new CombinedGraphQLErrors(result);\n                    if (aqr.dataState !== \"streaming\") {\n                        aqr.networkStatus = NetworkStatus.error;\n                    }\n                }\n            }\n            return aqr;\n        }), catchError((error) => {\n            // Avoid storing errors from older interrupted queries.\n            if (requestId >= queryInfo.lastRequestId && errorPolicy === \"none\") {\n                queryInfo.resetLastWrite();\n                observableQuery?.[\"resetNotifications\"]();\n                throw error;\n            }\n            const aqr = {\n                data: undefined,\n                dataState: \"empty\",\n                loading: false,\n                networkStatus: NetworkStatus.ready,\n                partial: true,\n            };\n            if (errorPolicy !== \"ignore\") {\n                aqr.error = error;\n                aqr.networkStatus = NetworkStatus.error;\n            }\n            return of(aqr);\n        }));\n    }\n    fetchObservableWithInfo(options, { \n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus = NetworkStatus.loading, query = options.query, fetchQueryOperator = (x) => x, onCacheHit = () => { }, observableQuery, }) {\n        const variables = this.getVariables(query, options.variables);\n        const defaults = this.defaultOptions.watchQuery;\n        let { fetchPolicy = (defaults && defaults.fetchPolicy) || \"cache-first\", errorPolicy = (defaults && defaults.errorPolicy) || \"none\", returnPartialData = false, notifyOnNetworkStatusChange = true, context = {}, } = options;\n        if (this.prioritizeCacheValues &&\n            (fetchPolicy === \"network-only\" || fetchPolicy === \"cache-and-network\")) {\n            fetchPolicy = \"cache-first\";\n        }\n        const normalized = Object.assign({}, options, {\n            query,\n            variables,\n            fetchPolicy,\n            errorPolicy,\n            returnPartialData,\n            notifyOnNetworkStatusChange,\n            context,\n        });\n        const queryInfo = new QueryInfo(this, observableQuery);\n        const fromVariables = (variables) => {\n            // Since normalized is always a fresh copy of options, it's safe to\n            // modify its properties here, rather than creating yet another new\n            // WatchQueryOptions object.\n            normalized.variables = variables;\n            const cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */\n                // Watched queries must opt into overwriting existing data on refetch,\n                // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n                : (networkStatus === NetworkStatus.refetch &&\n                    normalized.refetchWritePolicy !== \"merge\") ?\n                    1 /* CacheWriteBehavior.OVERWRITE */\n                    : 2 /* CacheWriteBehavior.MERGE */;\n            const observableWithInfo = this.fetchQueryByPolicy(normalized, { queryInfo, cacheWriteBehavior, onCacheHit, observableQuery });\n            observableWithInfo.observable =\n                observableWithInfo.observable.pipe(fetchQueryOperator);\n            if (\n            // If we're in standby, postpone advancing options.fetchPolicy using\n            // applyNextFetchPolicy.\n            normalized.fetchPolicy !== \"standby\") {\n                observableQuery?.[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n            }\n            return observableWithInfo;\n        };\n        // This cancel function needs to be set before the concast is created,\n        // in case concast creation synchronously cancels the request.\n        const cleanupCancelFn = () => {\n            this.fetchCancelFns.delete(queryInfo.id);\n        };\n        this.fetchCancelFns.set(queryInfo.id, (error) => {\n            fetchCancelSubject.next({\n                kind: \"E\",\n                error,\n                source: \"network\",\n            });\n        });\n        const fetchCancelSubject = new Subject();\n        let observable, containsDataFromLink;\n        // If the query has @export(as: ...) directives, then we need to\n        // process those directives asynchronously. When there are no\n        // @export directives (the common case), we deliberately avoid\n        // wrapping the result of this.fetchQueryByPolicy in a Promise,\n        // since the timing of result delivery is (unfortunately) important\n        // for backwards compatibility. TODO This code could be simpler if\n        // we deprecated and removed LocalState.\n        if (this.getDocumentInfo(normalized.query).hasClientExports) {\n            if (__DEV__) {\n                invariant(this.localState, 92, getOperationName(normalized.query, \"(anonymous)\"));\n            }\n            observable = from(this.localState.getExportedVariables({\n                client: this.client,\n                document: normalized.query,\n                variables: normalized.variables,\n                context: normalized.context,\n            })).pipe(mergeMap((variables) => fromVariables(variables).observable));\n            // there is just no way we can synchronously get the *right* value here,\n            // so we will assume `true`, which is the behaviour before the bug fix in\n            // #10597. This means that bug is not fixed in that case, and is probably\n            // un-fixable with reasonable effort for the edge case of @export as\n            // directives.\n            containsDataFromLink = true;\n        }\n        else {\n            const sourcesWithInfo = fromVariables(normalized.variables);\n            containsDataFromLink = sourcesWithInfo.fromLink;\n            observable = sourcesWithInfo.observable;\n        }\n        return {\n            // Merge `observable` with `fetchCancelSubject`, in a way that completing or\n            // erroring either of them will complete the merged obserable.\n            observable: new Observable((observer) => {\n                observer.add(cleanupCancelFn);\n                observable.subscribe(observer);\n                fetchCancelSubject.subscribe(observer);\n            }).pipe(share()),\n            fromLink: containsDataFromLink,\n        };\n    }\n    refetchQueries({ updateCache, include, optimistic = false, removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0, onQueryUpdated, }) {\n        const includedQueriesByOq = new Map();\n        if (include) {\n            this.getObservableQueries(include).forEach((oq) => {\n                if (oq.options.fetchPolicy === \"cache-only\" || oq[\"variablesUnknown\"]) {\n                    return;\n                }\n                const current = oq.getCurrentResult();\n                includedQueriesByOq.set(oq, {\n                    oq,\n                    lastDiff: {\n                        result: current?.data,\n                        complete: !current?.partial,\n                    },\n                });\n            });\n        }\n        const results = new Map();\n        if (updateCache) {\n            const handled = new Set();\n            this.cache.batch({\n                update: updateCache,\n                // Since you can perform any combination of cache reads and/or writes in\n                // the cache.batch update function, its optimistic option can be either\n                // a boolean or a string, representing three distinct modes of\n                // operation:\n                //\n                // * false: read/write only the root layer\n                // * true: read/write the topmost layer\n                // * string: read/write a fresh optimistic layer with that ID string\n                //\n                // When typeof optimistic === \"string\", a new optimistic layer will be\n                // temporarily created within cache.batch with that string as its ID. If\n                // we then pass that same string as the removeOptimistic option, we can\n                // make cache.batch immediately remove the optimistic layer after\n                // running the updateCache function, triggering only one broadcast.\n                //\n                // However, the refetchQueries method accepts only true or false for its\n                // optimistic option (not string). We interpret true to mean a temporary\n                // optimistic layer should be created, to allow efficiently rolling back\n                // the effect of the updateCache function, which involves passing a\n                // string instead of true as the optimistic option to cache.batch, when\n                // refetchQueries receives optimistic: true.\n                //\n                // In other words, we are deliberately not supporting the use case of\n                // writing to an *existing* optimistic layer (using the refetchQueries\n                // updateCache function), since that would potentially interfere with\n                // other optimistic updates in progress. Instead, you can read/write\n                // only the root layer by passing optimistic: false to refetchQueries,\n                // or you can read/write a brand new optimistic layer that will be\n                // automatically removed by passing optimistic: true.\n                optimistic: (optimistic && removeOptimistic) || false,\n                // The removeOptimistic option can also be provided by itself, even if\n                // optimistic === false, to remove some previously-added optimistic\n                // layer safely and efficiently, like we do in markMutationResult.\n                //\n                // If an explicit removeOptimistic string is provided with optimistic:\n                // true, the removeOptimistic string will determine the ID of the\n                // temporary optimistic layer, in case that ever matters.\n                removeOptimistic,\n                onWatchUpdated(watch, diff, lastDiff) {\n                    const oq = watch.watcher;\n                    if (oq instanceof ObservableQuery && !handled.has(oq)) {\n                        handled.add(oq);\n                        if (onQueryUpdated) {\n                            // Since we're about to handle this query now, remove it from\n                            // includedQueriesById, in case it was added earlier because of\n                            // options.include.\n                            includedQueriesByOq.delete(oq);\n                            let result = onQueryUpdated(oq, diff, lastDiff);\n                            if (result === true) {\n                                // The onQueryUpdated function requested the default refetching\n                                // behavior by returning true.\n                                result = oq\n                                    .refetch()\n                                    .retain( /* create a persistent subscription on the query */);\n                            }\n                            // Record the result in the results Map, as long as onQueryUpdated\n                            // did not return false to skip/ignore this result.\n                            if (result !== false) {\n                                results.set(oq, result);\n                            }\n                            // Allow the default cache broadcast to happen, except when\n                            // onQueryUpdated returns false.\n                            return result;\n                        }\n                        if (onQueryUpdated !== null &&\n                            oq.options.fetchPolicy !== \"cache-only\") {\n                            // If we don't have an onQueryUpdated function, and onQueryUpdated\n                            // was not disabled by passing null, make sure this query is\n                            // \"included\" like any other options.include-specified query.\n                            includedQueriesByOq.set(oq, { oq, lastDiff, diff });\n                        }\n                    }\n                },\n            });\n        }\n        if (includedQueriesByOq.size) {\n            includedQueriesByOq.forEach(({ oq, lastDiff, diff }) => {\n                let result;\n                // If onQueryUpdated is provided, we want to use it for all included\n                // queries, even the QueryOptions ones.\n                if (onQueryUpdated) {\n                    if (!diff) {\n                        diff = oq.getCacheDiff();\n                    }\n                    result = onQueryUpdated(oq, diff, lastDiff);\n                }\n                // Otherwise, we fall back to refetching.\n                if (!onQueryUpdated || result === true) {\n                    result = oq\n                        .refetch()\n                        .retain( /* create a persistent subscription on the query */);\n                }\n                if (result !== false) {\n                    results.set(oq, result);\n                }\n            });\n        }\n        if (removeOptimistic) {\n            // In case no updateCache callback was provided (so cache.batch was not\n            // called above, and thus did not already remove the optimistic layer),\n            // remove it here. Since this is a no-op when the layer has already been\n            // removed, we do it even if we called cache.batch above, since it's\n            // possible this.cache is an instance of some ApolloCache subclass other\n            // than InMemoryCache, and does not fully support the removeOptimistic\n            // option for cache.batch.\n            this.cache.removeOptimistic(removeOptimistic);\n        }\n        return results;\n    }\n    noCacheWarningsByCause = new WeakSet();\n    maskOperation(options) {\n        const { document, data } = options;\n        if (__DEV__) {\n            const { fetchPolicy, cause = {} } = options;\n            const operationType = getOperationDefinition(document)?.operation;\n            if (this.dataMasking &&\n                fetchPolicy === \"no-cache\" &&\n                !isFullyUnmaskedOperation(document) &&\n                !this.noCacheWarningsByCause.has(cause)) {\n                this.noCacheWarningsByCause.add(cause);\n                __DEV__ && invariant.warn(93, getOperationName(document, `Unnamed ${operationType ?? \"operation\"}`));\n            }\n        }\n        return (this.dataMasking ?\n            maskOperation(data, document, this.cache)\n            : data);\n    }\n    maskFragment(options) {\n        const { data, fragment, fragmentName } = options;\n        return this.dataMasking ?\n            maskFragment(data, fragment, this.cache, fragmentName)\n            : data;\n    }\n    fetchQueryByPolicy({ query, variables, fetchPolicy, errorPolicy, returnPartialData, context, }, { cacheWriteBehavior, onCacheHit, queryInfo, observableQuery, }) {\n        const readCache = () => this.cache.diff({\n            query,\n            variables,\n            returnPartialData: true,\n            optimistic: true,\n        });\n        const resultsFromCache = (diff, networkStatus) => {\n            const data = diff.result;\n            if (__DEV__ && !returnPartialData && data !== null) {\n                logMissingFieldErrors(diff.missing);\n            }\n            const toResult = (data) => {\n                // TODO: Eventually we should move this handling into\n                // queryInfo.getDiff() directly. Since getDiff is updated to return null\n                // on returnPartialData: false, we should take advantage of that instead\n                // of having to patch it elsewhere.\n                if (!diff.complete && !returnPartialData) {\n                    data = undefined;\n                }\n                return {\n                    // TODO: Handle partial data\n                    data: data,\n                    dataState: diff.complete ? \"complete\"\n                        : data ? \"partial\"\n                            : \"empty\",\n                    loading: isNetworkRequestInFlight(networkStatus),\n                    networkStatus,\n                    partial: !diff.complete,\n                };\n            };\n            const fromData = (data) => {\n                return of({\n                    kind: \"N\",\n                    value: toResult(data),\n                    source: \"cache\",\n                });\n            };\n            if (\n            // Don't attempt to run forced resolvers if we have incomplete cache\n            // data and partial isn't allowed since this result would get set to\n            // `undefined` anyways in `toResult`.\n            (diff.complete || returnPartialData) &&\n                this.getDocumentInfo(query).hasForcedResolvers) {\n                if (__DEV__) {\n                    invariant(this.localState, 94, getOperationName(query, \"(anonymous)\"));\n                }\n                onCacheHit();\n                return from(this.localState.execute({\n                    client: this.client,\n                    document: query,\n                    remoteResult: data ? { data } : undefined,\n                    context,\n                    variables,\n                    onlyRunForcedResolvers: true,\n                    returnPartialData: true,\n                }).then((resolved) => ({\n                    kind: \"N\",\n                    value: toResult(resolved.data || void 0),\n                    source: \"cache\",\n                })));\n            }\n            // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n            // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n            // data was incorrectly returned from the cache on refetch:\n            // if diff.missing exists, we should not return cache data.\n            if (errorPolicy === \"none\" &&\n                networkStatus === NetworkStatus.refetch &&\n                diff.missing) {\n                return fromData(void 0);\n            }\n            return fromData(data || undefined);\n        };\n        const resultsFromLink = () => this.getResultsFromLink({\n            query,\n            variables,\n            context,\n            fetchPolicy,\n            errorPolicy,\n        }, {\n            cacheWriteBehavior,\n            queryInfo,\n            observableQuery,\n        }).pipe(validateDidEmitValue(), materialize(), map((result) => ({\n            ...result,\n            source: \"network\",\n        })));\n        switch (fetchPolicy) {\n            default:\n            case \"cache-first\": {\n                const diff = readCache();\n                if (diff.complete) {\n                    return {\n                        fromLink: false,\n                        observable: resultsFromCache(diff, NetworkStatus.ready),\n                    };\n                }\n                if (returnPartialData) {\n                    return {\n                        fromLink: true,\n                        observable: concat(resultsFromCache(diff, NetworkStatus.loading), resultsFromLink()),\n                    };\n                }\n                return { fromLink: true, observable: resultsFromLink() };\n            }\n            case \"cache-and-network\": {\n                const diff = readCache();\n                if (diff.complete || returnPartialData) {\n                    return {\n                        fromLink: true,\n                        observable: concat(resultsFromCache(diff, NetworkStatus.loading), resultsFromLink()),\n                    };\n                }\n                return { fromLink: true, observable: resultsFromLink() };\n            }\n            case \"cache-only\":\n                return {\n                    fromLink: false,\n                    observable: concat(resultsFromCache(readCache(), NetworkStatus.ready)),\n                };\n            case \"network-only\":\n                return { fromLink: true, observable: resultsFromLink() };\n            case \"no-cache\":\n                return { fromLink: true, observable: resultsFromLink() };\n            case \"standby\":\n                return { fromLink: false, observable: EMPTY };\n        }\n    }\n}\nfunction validateDidEmitValue() {\n    let didEmitValue = false;\n    return tap({\n        next() {\n            didEmitValue = true;\n        },\n        complete() {\n            invariant(didEmitValue, 95);\n        },\n    });\n}\nfunction isFullyUnmaskedOperation(document) {\n    let isUnmasked = true;\n    visit(document, {\n        FragmentSpread: (node) => {\n            isUnmasked =\n                !!node.directives &&\n                    node.directives.some((directive) => directive.name.value === \"unmask\");\n            if (!isUnmasked) {\n                return BREAK;\n            }\n        },\n    });\n    return isUnmasked;\n}\nfunction addNonReactiveToNamedFragments(document) {\n    return visit(document, {\n        FragmentSpread: (node) => {\n            // Do not add `@nonreactive` if the fragment is marked with `@unmask`\n            // since we want to react to changes in this fragment.\n            if (node.directives?.some((directive) => directive.name.value === \"unmask\")) {\n                return;\n            }\n            return {\n                ...node,\n                directives: [\n                    ...(node.directives || []),\n                    {\n                        kind: Kind.DIRECTIVE,\n                        name: { kind: Kind.NAME, value: \"nonreactive\" },\n                    },\n                ],\n            };\n        },\n    });\n}\n\n", "import { OperationTypeNode } from \"graphql\";\nimport { map } from \"rxjs\";\nimport { NotImplementedHandler } from \"@apollo/client/incremental\";\nimport { execute } from \"@apollo/client/link\";\nimport { DocumentTransform } from \"@apollo/client/utilities\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { checkDocument, compact, getApolloClientMemoryInternals, mergeOptions, removeMaskedFragmentSpreads, } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { version } from \"../version.js\";\nimport { QueryManager } from \"./QueryManager.js\";\nlet hasSuggestedDevtools = false;\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an `ApolloLink` instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through `Observable` instances.\n */\nexport class ApolloClient {\n    link;\n    cache;\n    /**\n     * @deprecated `disableNetworkFetches` has been renamed to `prioritizeCacheValues`.\n     */\n    disableNetworkFetches;\n    set prioritizeCacheValues(value) {\n        this.queryManager.prioritizeCacheValues = value;\n    }\n    /**\n     * Whether to prioritize cache values over network results when `query` or `watchQuery` is called.\n     * This will essentially turn a `\"network-only\"` or `\"cache-and-network\"` fetchPolicy into a `\"cache-first\"` fetchPolicy,\n     * but without influencing the `fetchPolicy` of the created `ObservableQuery` long-term.\n     *\n     * This can e.g. be used to prioritize the cache during the first render after SSR.\n     */\n    get prioritizeCacheValues() {\n        return this.queryManager.prioritizeCacheValues;\n    }\n    version;\n    queryDeduplication;\n    defaultOptions;\n    devtoolsConfig;\n    queryManager;\n    devToolsHookCb;\n    resetStoreCallbacks = [];\n    clearStoreCallbacks = [];\n    /**\n     * Constructs an instance of `ApolloClient`.\n     *\n     * @example\n     *\n     * ```js\n     * import { ApolloClient, InMemoryCache } from \"@apollo/client\";\n     *\n     * const cache = new InMemoryCache();\n     *\n     * const client = new ApolloClient({\n     *   // Provide required constructor fields\n     *   cache: cache,\n     *   uri: \"http://localhost:4000/\",\n     *\n     *   // Provide some optional constructor fields\n     *   name: \"react-web-client\",\n     *   version: \"1.3\",\n     *   queryDeduplication: false,\n     *   defaultOptions: {\n     *     watchQuery: {\n     *       fetchPolicy: \"cache-and-network\",\n     *     },\n     *   },\n     * });\n     * ```\n     */\n    constructor(options) {\n        if (__DEV__) {\n            invariant(options.cache, 65);\n            invariant(options.link, 66);\n        }\n        const { cache, documentTransform, ssrMode = false, ssrForceFetchDelay = 0, queryDeduplication = true, defaultOptions, defaultContext, assumeImmutableResults = cache.assumeImmutableResults, localState, devtools, dataMasking, link, incrementalHandler = new NotImplementedHandler(), } = options;\n        this.link = link;\n        this.cache = cache;\n        this.queryDeduplication = queryDeduplication;\n        this.defaultOptions = defaultOptions || {};\n        this.devtoolsConfig = {\n            ...devtools,\n            enabled: devtools?.enabled ?? __DEV__,\n        };\n        this.watchQuery = this.watchQuery.bind(this);\n        this.query = this.query.bind(this);\n        this.mutate = this.mutate.bind(this);\n        this.watchFragment = this.watchFragment.bind(this);\n        this.resetStore = this.resetStore.bind(this);\n        this.reFetchObservableQueries = this.refetchObservableQueries =\n            this.refetchObservableQueries.bind(this);\n        this.version = version;\n        this.queryManager = new QueryManager({\n            client: this,\n            defaultOptions: this.defaultOptions,\n            defaultContext,\n            documentTransform,\n            queryDeduplication,\n            ssrMode,\n            dataMasking: !!dataMasking,\n            clientOptions: options,\n            incrementalHandler,\n            assumeImmutableResults,\n            onBroadcast: this.devtoolsConfig.enabled ?\n                () => {\n                    if (this.devToolsHookCb) {\n                        this.devToolsHookCb();\n                    }\n                }\n                : void 0,\n            localState,\n        });\n        this.prioritizeCacheValues = ssrMode || ssrForceFetchDelay > 0;\n        if (ssrForceFetchDelay) {\n            setTimeout(() => {\n                this.prioritizeCacheValues = false;\n            }, ssrForceFetchDelay);\n        }\n        if (this.devtoolsConfig.enabled)\n            this.connectToDevTools();\n    }\n    connectToDevTools() {\n        if (typeof window === \"undefined\") {\n            return;\n        }\n        const windowWithDevTools = window;\n        const devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n        (windowWithDevTools[devtoolsSymbol] =\n            windowWithDevTools[devtoolsSymbol] || []).push(this);\n        windowWithDevTools.__APOLLO_CLIENT__ = this;\n        /**\n         * Suggest installing the devtools for developers who don't have them\n         */\n        if (!hasSuggestedDevtools && __DEV__) {\n            hasSuggestedDevtools = true;\n            if (window.document &&\n                window.top === window.self &&\n                /^(https?|file):$/.test(window.location.protocol)) {\n                setTimeout(() => {\n                    if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n                        const nav = window.navigator;\n                        const ua = nav && nav.userAgent;\n                        let url;\n                        if (typeof ua === \"string\") {\n                            if (ua.indexOf(\"Chrome/\") > -1) {\n                                url =\n                                    \"https://chrome.google.com/webstore/detail/\" +\n                                        \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n                            }\n                            else if (ua.indexOf(\"Firefox/\") > -1) {\n                                url =\n                                    \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n                            }\n                        }\n                        if (url) {\n                            __DEV__ && invariant.log(\"Download the Apollo DevTools for a better development \" +\n                                \"experience: %s\", url);\n                        }\n                    }\n                }, 10000);\n            }\n        }\n    }\n    /**\n     * The `DocumentTransform` used to modify GraphQL documents before a request\n     * is made. If a custom `DocumentTransform` is not provided, this will be the\n     * default document transform.\n     */\n    get documentTransform() {\n        return this.queryManager.documentTransform;\n    }\n    /**\n     * The configured `LocalState` instance used to enable the use of `@client`\n     * fields.\n     */\n    get localState() {\n        return this.queryManager.localState;\n    }\n    set localState(localState) {\n        this.queryManager.localState = localState;\n    }\n    /**\n     * Call this method to terminate any active client processes, making it safe\n     * to dispose of this `ApolloClient` instance.\n     *\n     * This method performs aggressive cleanup to prevent memory leaks:\n     *\n     * - Unsubscribes all active `ObservableQuery` instances by emitting a `completed` event\n     * - Rejects all currently running queries with \"QueryManager stopped while query was in flight\"\n     * - Removes all queryRefs from the suspense cache\n     */\n    stop() {\n        this.queryManager.stop();\n    }\n    /**\n     * This watches the cache store of the query according to the options specified and\n     * returns an `ObservableQuery`. We can subscribe to this `ObservableQuery` and\n     * receive updated results through an observer when the cache store changes.\n     *\n     * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n     * it uses Apollo's store in order to reactively deliver updates to your query results.\n     *\n     * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n     * first and last name and this person has a particular object identifier, provided by\n     * `cache.identify`. Later, a different query fetches that same person's\n     * first and last name and the first name has now changed. Then, any observers associated\n     * with the results of the first query will be updated with a new result object.\n     *\n     * Note that if the cache does not change, the subscriber will _not_ be notified.\n     *\n     * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n     * a description of store reactivity.\n     */\n    watchQuery(options) {\n        if (this.defaultOptions.watchQuery) {\n            options = mergeOptions(this.defaultOptions.watchQuery, options);\n        }\n        return this.queryManager.watchQuery(options);\n    }\n    /**\n     * This resolves a single query according to the options specified and\n     * returns a `Promise` which is either resolved with the resulting data\n     * or rejected with an error.\n     *\n     * @param options - An object of type `QueryOptions` that allows us to\n     * describe how this query should be treated e.g. whether it should hit the\n     * server at all or just resolve from the cache, etc.\n     */\n    query(options) {\n        if (this.defaultOptions.query) {\n            options = mergeOptions(this.defaultOptions.query, options);\n        }\n        if (__DEV__) {\n            invariant(options.fetchPolicy !== \"cache-and-network\", 67);\n            invariant(options.fetchPolicy !== \"standby\", 68);\n            invariant(options.query, 69);\n            invariant(options.query.kind === \"Document\", 70);\n            invariant(!options.returnPartialData, 71);\n            invariant(!options.pollInterval, 72);\n            invariant(!options.notifyOnNetworkStatusChange, 73);\n        }\n        return this.queryManager.query(options);\n    }\n    /**\n     * This resolves a single mutation according to the options specified and returns a\n     * Promise which is either resolved with the resulting data or rejected with an\n     * error. In some cases both `data` and `errors` might be undefined, for example\n     * when `errorPolicy` is set to `'ignore'`.\n     *\n     * It takes options as an object with the following keys and values:\n     */\n    mutate(options) {\n        const optionsWithDefaults = mergeOptions(compact({\n            fetchPolicy: \"network-only\",\n            errorPolicy: \"none\",\n        }, this.defaultOptions.mutate), options);\n        if (__DEV__) {\n            invariant(optionsWithDefaults.mutation, 74);\n            invariant(optionsWithDefaults.fetchPolicy === \"network-only\" ||\n                optionsWithDefaults.fetchPolicy === \"no-cache\", 75);\n        }\n        checkDocument(optionsWithDefaults.mutation, OperationTypeNode.MUTATION);\n        return this.queryManager.mutate(optionsWithDefaults);\n    }\n    /**\n     * This subscribes to a graphql subscription according to the options specified and returns an\n     * `Observable` which either emits received data or an error.\n     */\n    subscribe(options) {\n        const cause = {};\n        const observable = this.queryManager.startGraphQLSubscription(options);\n        const mapped = observable.pipe(map((result) => ({\n            ...result,\n            data: this.queryManager.maskOperation({\n                document: options.query,\n                data: result.data,\n                fetchPolicy: options.fetchPolicy,\n                cause,\n            }),\n        })));\n        return Object.assign(mapped, { restart: observable.restart });\n    }\n    readQuery(options, optimistic = false) {\n        return this.cache.readQuery({ ...options, query: this.transform(options.query) }, optimistic);\n    }\n    /**\n     * Watches the cache store of the fragment according to the options specified\n     * and returns an `Observable`. We can subscribe to this\n     * `Observable` and receive updated results through an\n     * observer when the cache store changes.\n     *\n     * You must pass in a GraphQL document with a single fragment or a document\n     * with multiple fragments that represent what you are reading. If you pass\n     * in a document with multiple fragments then you must also specify a\n     * `fragmentName`.\n     *\n     * @since 3.10.0\n     * @param options - An object of type `WatchFragmentOptions` that allows\n     * the cache to identify the fragment and optionally specify whether to react\n     * to optimistic updates.\n     */\n    watchFragment(options) {\n        const dataMasking = this.queryManager.dataMasking;\n        return this.cache\n            .watchFragment({\n            ...options,\n            fragment: this.transform(options.fragment, dataMasking),\n        })\n            .pipe(map((result) => {\n            // The transform will remove fragment spreads from the fragment\n            // document when dataMasking is enabled. The `maskFragment` function\n            // remains to apply warnings to fragments marked as\n            // `@unmask(mode: \"migrate\")`. Since these warnings are only applied\n            // in dev, we can skip the masking algorithm entirely for production.\n            if (__DEV__) {\n                if (dataMasking) {\n                    const data = this.queryManager.maskFragment({\n                        ...options,\n                        data: result.data,\n                    });\n                    return { ...result, data };\n                }\n            }\n            return result;\n        }));\n    }\n    readFragment(options, optimistic = false) {\n        return this.cache.readFragment({ ...options, fragment: this.transform(options.fragment) }, optimistic);\n    }\n    /**\n     * Writes some data in the shape of the provided GraphQL query directly to\n     * the store. This method will start at the root query. To start at a\n     * specific id returned by `cache.identify` then use `writeFragment`.\n     */\n    writeQuery(options) {\n        const ref = this.cache.writeQuery(options);\n        if (options.broadcast !== false) {\n            this.queryManager.broadcastQueries();\n        }\n        return ref;\n    }\n    /**\n     * Writes some data in the shape of the provided GraphQL fragment directly to\n     * the store. This method will write to a GraphQL fragment from any arbitrary\n     * id that is currently cached, unlike `writeQuery` which will only write\n     * from the root query.\n     *\n     * You must pass in a GraphQL document with a single fragment or a document\n     * with multiple fragments that represent what you are writing. If you pass\n     * in a document with multiple fragments then you must also specify a\n     * `fragmentName`.\n     */\n    writeFragment(options) {\n        const ref = this.cache.writeFragment(options);\n        if (options.broadcast !== false) {\n            this.queryManager.broadcastQueries();\n        }\n        return ref;\n    }\n    __actionHookForDevTools(cb) {\n        this.devToolsHookCb = cb;\n    }\n    __requestRaw(request) {\n        return execute(this.link, request, { client: this });\n    }\n    /**\n     * Resets your entire store by clearing out your cache and then re-executing\n     * all of your active queries. This makes it so that you may guarantee that\n     * there is no data left in your store from a time before you called this\n     * method.\n     *\n     * `resetStore()` is useful when your user just logged out. Youve removed the\n     * user session, and you now want to make sure that any references to data you\n     * might have fetched while the user session was active is gone.\n     *\n     * It is important to remember that `resetStore()` _will_ refetch any active\n     * queries. This means that any components that might be mounted will execute\n     * their queries again using your network interface. If you do not want to\n     * re-execute any queries then you should make sure to stop watching any\n     * active queries.\n     */\n    resetStore() {\n        return Promise.resolve()\n            .then(() => this.queryManager.clearStore({\n            discardWatches: false,\n        }))\n            .then(() => Promise.all(this.resetStoreCallbacks.map((fn) => fn())))\n            .then(() => this.refetchObservableQueries());\n    }\n    /**\n     * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n     * not refetch any active queries.\n     */\n    clearStore() {\n        return Promise.resolve()\n            .then(() => this.queryManager.clearStore({\n            discardWatches: true,\n        }))\n            .then(() => Promise.all(this.clearStoreCallbacks.map((fn) => fn())));\n    }\n    /**\n     * Allows callbacks to be registered that are executed when the store is\n     * reset. `onResetStore` returns an unsubscribe function that can be used\n     * to remove registered callbacks.\n     */\n    onResetStore(cb) {\n        this.resetStoreCallbacks.push(cb);\n        return () => {\n            this.resetStoreCallbacks = this.resetStoreCallbacks.filter((c) => c !== cb);\n        };\n    }\n    /**\n     * Allows callbacks to be registered that are executed when the store is\n     * cleared. `onClearStore` returns an unsubscribe function that can be used\n     * to remove registered callbacks.\n     */\n    onClearStore(cb) {\n        this.clearStoreCallbacks.push(cb);\n        return () => {\n            this.clearStoreCallbacks = this.clearStoreCallbacks.filter((c) => c !== cb);\n        };\n    }\n    /**\n     * Refetches all of your active queries.\n     *\n     * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n     *\n     * It is important to remember that `reFetchObservableQueries()` _will_ refetch any active\n     * queries. This means that any components that might be mounted will execute\n     * their queries again using your network interface. If you do not want to\n     * re-execute any queries then you should make sure to stop watching any\n     * active queries.\n     * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n     *\n     * Note: `cache-only` queries are not refetched by this function.\n     *\n     * @deprecated Please use `refetchObservableQueries` instead.\n     */\n    reFetchObservableQueries;\n    /**\n     * Refetches all of your active queries.\n     *\n     * `refetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n     *\n     * It is important to remember that `refetchObservableQueries()` _will_ refetch any active\n     * queries. This means that any components that might be mounted will execute\n     * their queries again using your network interface. If you do not want to\n     * re-execute any queries then you should make sure to stop watching any\n     * active queries.\n     * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n     *\n     * Note: `cache-only` queries are not refetched by this function.\n     */\n    refetchObservableQueries(includeStandby) {\n        return this.queryManager.refetchObservableQueries(includeStandby);\n    }\n    /**\n     * Refetches specified active queries. Similar to \"refetchObservableQueries()\" but with a specific list of queries.\n     *\n     * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n     *\n     * It is important to remember that `refetchQueries()` _will_ refetch specified active\n     * queries. This means that any components that might be mounted will execute\n     * their queries again using your network interface. If you do not want to\n     * re-execute any queries then you should make sure to stop watching any\n     * active queries.\n     */\n    refetchQueries(options) {\n        const map = this.queryManager.refetchQueries(options);\n        const queries = [];\n        const results = [];\n        map.forEach((result, obsQuery) => {\n            queries.push(obsQuery);\n            results.push(result);\n        });\n        const result = Promise.all(results);\n        // In case you need the raw results immediately, without awaiting\n        // Promise.all(results):\n        result.queries = queries;\n        result.results = results;\n        // If you decide to ignore the result Promise because you're using\n        // result.queries and result.results instead, you shouldn't have to worry\n        // about preventing uncaught rejections for the Promise.all result.\n        result.catch((error) => {\n            __DEV__ && invariant.debug(76, error);\n        });\n        return result;\n    }\n    /**\n     * Get all currently active `ObservableQuery` objects, in a `Set`.\n     *\n     * An \"active\" query is one that has observers and a `fetchPolicy` other than\n     * \"standby\" or \"cache-only\".\n     *\n     * You can include all `ObservableQuery` objects (including the inactive ones)\n     * by passing \"all\" instead of \"active\", or you can include just a subset of\n     * active queries by passing an array of query names or DocumentNode objects.\n     *\n     * Note: This method only returns queries that have active subscribers. Queries\n     * without subscribers are not tracked by the client.\n     */\n    getObservableQueries(include = \"active\") {\n        return this.queryManager.getObservableQueries(include);\n    }\n    /**\n     * Exposes the cache's complete state, in a serializable format for later restoration.\n     *\n     * @remarks\n     *\n     * This can be useful for debugging in order to inspect the full state of the\n     * cache.\n     *\n     * @param optimistic - Determines whether the result contains data from the\n     * optimistic layer\n     */\n    extract(optimistic) {\n        return this.cache.extract(optimistic);\n    }\n    /**\n     * Replaces existing state in the cache (if any) with the values expressed by\n     * `serializedState`.\n     *\n     * Called when hydrating a cache (server side rendering, or offline storage),\n     * and also (potentially) during hot reloads.\n     */\n    restore(serializedState) {\n        return this.cache.restore(serializedState);\n    }\n    /**\n     * Define a new ApolloLink (or link chain) that Apollo Client will use.\n     */\n    setLink(newLink) {\n        this.link = newLink;\n    }\n    get defaultContext() {\n        return this.queryManager.defaultContext;\n    }\n    maskedFragmentTransform = new DocumentTransform(removeMaskedFragmentSpreads);\n    transform(document, dataMasking = false) {\n        const transformed = this.queryManager.transform(document);\n        return dataMasking ?\n            this.maskedFragmentTransform.transformDocument(transformed)\n            : transformed;\n    }\n}\nif (__DEV__) {\n    ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;\n}\n\n", "import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\nfunction normalize(string) {\n    return string.replace(/[\\s,]+/g, ' ').trim();\n}\nfunction cacheKeyFromLoc(loc) {\n    return normalize(loc.source.body.substring(loc.start, loc.end));\n}\nfunction processFragments(ast) {\n    var seenKeys = new Set();\n    var definitions = [];\n    ast.definitions.forEach(function (fragmentDefinition) {\n        if (fragmentDefinition.kind === 'FragmentDefinition') {\n            var fragmentName = fragmentDefinition.name.value;\n            var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n            var sourceKeySet = fragmentSourceMap.get(fragmentName);\n            if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n                if (printFragmentWarnings) {\n                    console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n                        + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n                        + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n                }\n            }\n            else if (!sourceKeySet) {\n                fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n            }\n            sourceKeySet.add(sourceKey);\n            if (!seenKeys.has(sourceKey)) {\n                seenKeys.add(sourceKey);\n                definitions.push(fragmentDefinition);\n            }\n        }\n        else {\n            definitions.push(fragmentDefinition);\n        }\n    });\n    return __assign(__assign({}, ast), { definitions: definitions });\n}\nfunction stripLoc(doc) {\n    var workSet = new Set(doc.definitions);\n    workSet.forEach(function (node) {\n        if (node.loc)\n            delete node.loc;\n        Object.keys(node).forEach(function (key) {\n            var value = node[key];\n            if (value && typeof value === 'object') {\n                workSet.add(value);\n            }\n        });\n    });\n    var loc = doc.loc;\n    if (loc) {\n        delete loc.startToken;\n        delete loc.endToken;\n    }\n    return doc;\n}\nfunction parseDocument(source) {\n    var cacheKey = normalize(source);\n    if (!docCache.has(cacheKey)) {\n        var parsed = parse(source, {\n            experimentalFragmentVariables: experimentalFragmentVariables,\n            allowLegacyFragmentVariables: experimentalFragmentVariables\n        });\n        if (!parsed || parsed.kind !== 'Document') {\n            throw new Error('Not a valid GraphQL document.');\n        }\n        docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n    }\n    return docCache.get(cacheKey);\n}\nexport function gql(literals) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (typeof literals === 'string') {\n        literals = [literals];\n    }\n    var result = literals[0];\n    args.forEach(function (arg, i) {\n        if (arg && arg.kind === 'Document') {\n            result += arg.loc.source.body;\n        }\n        else {\n            result += arg;\n        }\n        result += literals[i + 1];\n    });\n    return parseDocument(result);\n}\nexport function resetCaches() {\n    docCache.clear();\n    fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n    printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = false;\n}\nvar extras = {\n    gql: gql,\n    resetCaches: resetCaches,\n    disableFragmentWarnings: disableFragmentWarnings,\n    enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n(function (gql_1) {\n    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\ngql[\"default\"] = gql;\nexport default gql;\n"],
  "mappings": "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",
  "names": ["from", "from", "fragment", "from", "d", "existing", "incoming", "from", "result", "dataId", "result", "context", "value", "selectionSet", "from", "map", "NetworkStatus", "finalize", "info", "subscription", "operation", "cache", "DELETE", "result", "variables", "observable", "data", "map", "result", "normalize"]
}
