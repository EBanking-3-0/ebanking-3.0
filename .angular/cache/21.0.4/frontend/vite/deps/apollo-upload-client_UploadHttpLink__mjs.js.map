{
  "version": 3,
  "sources": ["../../../../../../node_modules/is-plain-obj/index.js", "../../../../../../node_modules/extract-files/extractFiles.mjs", "../../../../../../node_modules/apollo-upload-client/formDataAppendFile.mjs", "../../../../../../node_modules/extract-files/isExtractableFile.mjs", "../../../../../../node_modules/apollo-upload-client/UploadHttpLink.mjs"],
  "sourcesContent": ["export default function isPlainObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n", "// @ts-check\n\n// @deno-types=\"is-plain-obj/index.d.ts\"\nimport isPlainObject from \"is-plain-obj\";\n\n/** @typedef {import(\"./isExtractableFile.mjs\").default} isExtractableFile */\n\n/**\n * Recursively extracts files and their {@link ObjectPath object paths} within a\n * value, replacing them with `null` in a deep clone without mutating the\n * original value.\n * [`FileList`](https://developer.mozilla.org/en-US/docs/Web/API/Filelist)\n * instances are treated as\n * [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) instance\n * arrays.\n * @template Extractable Extractable file type.\n * @param {unknown} value Value to extract files from. Typically an object tree.\n * @param {(value: unknown) => value is Extractable} isExtractable Matches\n *   extractable files. Typically {@linkcode isExtractableFile}.\n * @param {ObjectPath} [path] Prefix for object paths for extracted files.\n *   Defaults to `\"\"`.\n * @returns {Extraction<Extractable>} Extraction result.\n * @example\n * Extracting files from an object.\n *\n * For the following:\n *\n * ```js\n * import extractFiles from \"extract-files/extractFiles.mjs\";\n * import isExtractableFile from \"extract-files/isExtractableFile.mjs\";\n *\n * const file1 = new File([\"1\"], \"1.txt\", { type: \"text/plain\" });\n * const file2 = new File([\"2\"], \"2.txt\", { type: \"text/plain\" });\n * const value = {\n *   a: file1,\n *   b: [file1, file2],\n * };\n *\n * const { clone, files } = extractFiles(value, isExtractableFile, \"prefix\");\n * ```\n *\n * `value` remains the same.\n *\n * `clone` is:\n *\n * ```json\n * {\n *   \"a\": null,\n *   \"b\": [null, null]\n * }\n * ```\n *\n * `files` is a\n * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n * instance containing:\n *\n * | Key     | Value                        |\n * | :------ | :--------------------------- |\n * | `file1` | `[\"prefix.a\", \"prefix.b.0\"]` |\n * | `file2` | `[\"prefix.b.1\"]`             |\n */\nexport default function extractFiles(value, isExtractable, path = \"\") {\n  if (!arguments.length) throw new TypeError(\"Argument 1 `value` is required.\");\n\n  if (typeof isExtractable !== \"function\")\n    throw new TypeError(\"Argument 2 `isExtractable` must be a function.\");\n\n  if (typeof path !== \"string\")\n    throw new TypeError(\"Argument 3 `path` must be a string.\");\n\n  /**\n   * Deeply clonable value.\n   * @typedef {Array<unknown> | FileList | {\n   *   [key: PropertyKey]: unknown\n   * }} Cloneable\n   */\n\n  /**\n   * Clone of a {@link Cloneable deeply cloneable value}.\n   * @typedef {Exclude<Cloneable, FileList>} Clone\n   */\n\n  /**\n   * Map of values recursed within the input value and their clones, for reusing\n   * clones of values that are referenced multiple times within the input value.\n   * @type {Map<Cloneable, Clone>}\n   */\n  const clones = new Map();\n\n  /**\n   * Extracted files and their object paths within the input value.\n   * @type {Extraction<Extractable>[\"files\"]}\n   */\n  const files = new Map();\n\n  /**\n   * Recursively clones the value, extracting files.\n   * @param {unknown} value Value to extract files from.\n   * @param {ObjectPath} path Prefix for object paths for extracted files.\n   * @param {Set<Cloneable>} recursed Recursed values for avoiding infinite\n   *   recursion of circular references within the input value.\n   * @returns {unknown} Clone of the value with files replaced with `null`.\n   */\n  function recurse(value, path, recursed) {\n    if (isExtractable(value)) {\n      const filePaths = files.get(value);\n\n      filePaths ? filePaths.push(path) : files.set(value, [path]);\n\n      return null;\n    }\n\n    const valueIsList =\n      Array.isArray(value) ||\n      (typeof FileList !== \"undefined\" && value instanceof FileList);\n    const valueIsPlainObject = isPlainObject(value);\n\n    if (valueIsList || valueIsPlainObject) {\n      let clone = clones.get(value);\n\n      const uncloned = !clone;\n\n      if (uncloned) {\n        clone = valueIsList\n          ? []\n          : // Replicate if the plain object is an `Object` instance.\n          value instanceof /** @type {any} */ (Object)\n          ? {}\n          : Object.create(null);\n\n        clones.set(value, /** @type {Clone} */ (clone));\n      }\n\n      if (!recursed.has(value)) {\n        const pathPrefix = path ? `${path}.` : \"\";\n        const recursedDeeper = new Set(recursed).add(value);\n\n        if (valueIsList) {\n          let index = 0;\n\n          for (const item of value) {\n            const itemClone = recurse(\n              item,\n              pathPrefix + index++,\n              recursedDeeper\n            );\n\n            if (uncloned) /** @type {Array<unknown>} */ (clone).push(itemClone);\n          }\n        } else\n          for (const key in value) {\n            const propertyClone = recurse(\n              value[key],\n              pathPrefix + key,\n              recursedDeeper\n            );\n\n            if (uncloned)\n              /** @type {{ [key: PropertyKey]: unknown }} */ (clone)[key] =\n                propertyClone;\n          }\n      }\n\n      return clone;\n    }\n\n    return value;\n  }\n\n  return {\n    clone: recurse(value, path, new Set()),\n    files,\n  };\n}\n\n/**\n * An extraction result.\n * @template [Extractable=unknown] Extractable file type.\n * @typedef {object} Extraction\n * @prop {unknown} clone Clone of the original value with extracted files\n *   recursively replaced with `null`.\n * @prop {Map<Extractable, Array<ObjectPath>>} files Extracted files and their\n *   object paths within the original value.\n */\n\n/**\n * String notation for the path to a node in an object tree.\n * @typedef {string} ObjectPath\n * @see [`object-path` on npm](https://npm.im/object-path).\n * @example\n * An object path for object property `a`, array index `0`, object property `b`:\n *\n * ```\n * a.0.b\n * ```\n */\n", "// @ts-check\n\n/** @import { ExtractableFile } from \"./isExtractableFile.mjs\" */\n\n/**\n * The default implementation for the class `UploadHttpLink` constructor option\n * `formDataAppendFile` that uses the standard {@linkcode FormData.append}\n * method.\n * @param {FormData} formData Form data to append the specified file to.\n * @param {string} fieldName Field name for the file.\n * @param {ExtractableFile} file File to append.\n */\nexport default function formDataAppendFile(formData, fieldName, file) {\n  \"name\" in file\n    ? formData.append(fieldName, file, file.name)\n    : formData.append(fieldName, file);\n}\n", "// @ts-check\n\n/**\n * Checks if a value is an {@link ExtractableFile extractable file}.\n * @param {unknown} value Value to check.\n * @returns {value is ExtractableFile} Is the value an\n *   {@link ExtractableFile extractable file}.\n */\nexport default function isExtractableFile(value) {\n  return (\n    (typeof File !== \"undefined\" && value instanceof File) ||\n    (typeof Blob !== \"undefined\" && value instanceof Blob)\n  );\n}\n\n/**\n * An extractable file.\n * @typedef {File | Blob} ExtractableFile\n */\n", "// @ts-check\n\n/** @import { BaseHttpLink } from \"@apollo/client/link/http\" */\n\nimport { ApolloLink } from \"@apollo/client/link\";\nimport {\n  defaultPrinter,\n  fallbackHttpConfig,\n  parseAndCheckHttpResponse,\n  rewriteURIForGET,\n  selectHttpOptionsAndBodyInternal,\n  selectURI,\n} from \"@apollo/client/link/http\";\nimport { filterOperationVariables } from \"@apollo/client/link/utils\";\nimport extractFiles from \"extract-files/extractFiles.mjs\";\nimport { Observable } from \"rxjs/internal/Observable\";\n\nimport formDataAppendFile from \"./formDataAppendFile.mjs\";\nimport isExtractableFile from \"./isExtractableFile.mjs\";\n\n/**\n * A\n * [terminating Apollo Link](https://www.apollographql.com/docs/react/api/link/introduction#the-terminating-link)\n * for [Apollo Client](https://www.apollographql.com/docs/react) that fetches a\n * [GraphQL multipart request](https://github.com/jaydenseric/graphql-multipart-request-spec)\n * if the GraphQL variables contain files (by default\n * [`FileList`](https://developer.mozilla.org/en-US/docs/Web/API/FileList),\n * [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File), or\n * [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) instances),\n * or else fetches a regular\n * [GraphQL POST or GET request](https://www.apollographql.com/docs/apollo-server/workflow/requests)\n * (depending on the config and GraphQL operation).\n *\n * Some of the options are similar to the\n * [`BaseHttpLink` options](https://www.apollographql.com/docs/react/api/link/apollo-link-base-http#basehttplinkoptions).\n * @see [GraphQL multipart request spec](https://github.com/jaydenseric/graphql-multipart-request-spec).\n * @example\n * A basic Apollo Client setup:\n *\n * ```js\n * import { InMemoryCache } from \"@apollo/client/cache\";\n * import { ApolloClient } from \"@apollo/client/core\";\n * import UploadHttpLink from \"apollo-upload-client/UploadHttpLink.mjs\";\n *\n * const client = new ApolloClient({\n *   cache: new InMemoryCache(),\n *   link: new UploadHttpLink(),\n * });\n * ```\n */\nexport default class UploadHttpLink extends ApolloLink {\n  /**\n   * @param {object} options Options.\n   * @param {Parameters<typeof selectURI>[1]} [options.uri] GraphQL endpoint\n   *   URI. Defaults to `\"/graphql\"`.\n   * @param {boolean} [options.useGETForQueries] Should GET be used to fetch\n   *   queries, if there are no files to upload.\n   * @param {ExtractableFileMatcher} [options.isExtractableFile] Matches\n   *   extractable files in the GraphQL operation. Defaults to\n   *   {@linkcode isExtractableFile}.\n   * @param {typeof FormData} [options.FormData]\n   *   [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n   *   class. Defaults to the {@linkcode FormData} global.\n   * @param {FormDataFileAppender} [options.formDataAppendFile]\n   *   Customizes how extracted files are appended to the\n   *   [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n   *   instance. Defaults to {@linkcode formDataAppendFile}.\n   * @param {BaseHttpLink.Printer} [options.print] Prints the GraphQL query or\n   *   mutation AST to a string for transport. Defaults to\n   *   {@linkcode defaultPrinter}.\n   * @param {typeof fetch} [options.fetch]\n   *   [`fetch`](https://fetch.spec.whatwg.org) implementation. Defaults to the\n   *   {@linkcode fetch} global.\n   * @param {RequestInit} [options.fetchOptions] `fetch` options; overridden by\n   *   upload requirements.\n   * @param {string} [options.credentials] Overrides\n   *   {@linkcode RequestInit.credentials credentials} in\n   *   {@linkcode fetchOptions}.\n   * @param {{ [headerName: string]: string }} [options.headers] Merges with and\n   *   overrides {@linkcode RequestInit.headers headers} in\n   *   {@linkcode fetchOptions}.\n   * @param {boolean} [options.includeExtensions] Toggles sending `extensions`\n   *   fields to the GraphQL server. Defaults to `false`.\n   * @param {boolean} [options.includeUnusedVariables] Toggles including unused\n   *   GraphQL variables in the request. Defaults to `false`.\n   */\n  constructor({\n    uri: fetchUri = \"/graphql\",\n    useGETForQueries,\n    isExtractableFile: customIsExtractableFile = isExtractableFile,\n    FormData: CustomFormData,\n    formDataAppendFile: customFormDataAppendFile = formDataAppendFile,\n    print = defaultPrinter,\n    fetch: customFetch,\n    fetchOptions,\n    credentials,\n    headers,\n    includeExtensions,\n    includeUnusedVariables = false,\n  } = {}) {\n    super(\n      (operation) =>\n        new Observable((observer) => {\n          const context = operation.getContext();\n          const { options, body } = selectHttpOptionsAndBodyInternal(\n            operation,\n            print,\n            fallbackHttpConfig,\n            {\n              http: {\n                includeExtensions,\n              },\n              options: fetchOptions,\n              credentials,\n              headers,\n            },\n            {\n              http: context.http,\n              options: context.fetchOptions,\n              credentials: context.credentials,\n              headers: context.headers,\n            },\n          );\n\n          if (body.variables && !includeUnusedVariables)\n            body.variables = filterOperationVariables(\n              body.variables,\n              operation.query,\n            );\n\n          const { clone, files } = extractFiles(\n            body,\n            customIsExtractableFile,\n            \"\",\n          );\n\n          /**\n           * URI for the GraphQL request.\n           * @type {string}\n           */\n          let uri = selectURI(operation, fetchUri);\n\n          if (files.size) {\n            if (options.headers)\n              // Automatically set by `fetch` when the `body` is a `FormData`\n              // instance.\n              delete options.headers[\"content-type\"];\n\n            // GraphQL multipart request spec:\n            // https://github.com/jaydenseric/graphql-multipart-request-spec\n\n            const RuntimeFormData = CustomFormData || FormData;\n\n            const form = new RuntimeFormData();\n\n            form.append(\"operations\", JSON.stringify(clone));\n\n            /** @type {{ [key: string]: Array<string> }} */\n            const map = {};\n\n            let i = 0;\n            files.forEach((paths) => {\n              map[++i] = paths;\n            });\n            form.append(\"map\", JSON.stringify(map));\n\n            i = 0;\n            files.forEach((_paths, file) => {\n              customFormDataAppendFile(form, String(++i), file);\n            });\n\n            options.body = form;\n          } else {\n            if (\n              useGETForQueries &&\n              // If the operation contains some mutations GET shouldn’t be used.\n              !operation.query.definitions.some(\n                (definition) =>\n                  definition.kind === \"OperationDefinition\" &&\n                  definition.operation === \"mutation\",\n              )\n            )\n              options.method = \"GET\";\n\n            if (options.method === \"GET\") {\n              const result =\n                /** @type {{ newURI: string } | { parseError: unknown }} */ (\n                  // The return type is incorrect; `newURI` and `parseError`\n                  // will never both be present.\n                  rewriteURIForGET(uri, body)\n                );\n\n              if (\"parseError\" in result) throw result.parseError;\n\n              uri = result.newURI;\n            } else options.body = JSON.stringify(clone);\n          }\n\n          /**\n           * Abort controller for the GraphQL request.\n           * @type {AbortController}\n           */\n          let controller;\n\n          if (typeof AbortController !== \"undefined\") {\n            controller = new AbortController();\n\n            if (options.signal)\n              // Respect the user configured abort controller signal.\n              options.signal.aborted\n                ? // Signal already aborted, so immediately abort.\n                  controller.abort()\n                : // Signal not already aborted, so setup a listener to abort\n                  // when it does.\n                  options.signal.addEventListener(\n                    \"abort\",\n                    () => {\n                      controller.abort();\n                    },\n                    {\n                      // Prevent a memory leak if the user configured abort\n                      // controller is long lasting, or controls multiple\n                      // things.\n                      once: true,\n                    },\n                  );\n\n            options.signal = controller.signal;\n          }\n\n          /**\n           * Fetcher for the GraphQL request. Determined when fetching instead\n           * of when constructing the link to allow more time for instrumenting\n           * the global `fetch`.\n           * @see https://github.com/apollographql/apollo-client/issues/7832\n           */\n          const runtimeFetch = customFetch || fetch;\n\n          /**\n           * Is the observable being cleaned up.\n           * @type {boolean}\n           */\n          let cleaningUp;\n\n          runtimeFetch(uri, options)\n            .then((response) => {\n              // Forward the response on the context.\n              operation.setContext({ response });\n              return response;\n            })\n            .then(parseAndCheckHttpResponse(operation))\n            .then((result) => {\n              observer.next(result);\n              observer.complete();\n            })\n            .catch((error) => {\n              // If the observable is being cleaned up, there is no need to call\n              // next or error because there are no more subscribers. An error\n              // after cleanup begins is likely from the cleanup function\n              // aborting the fetch.\n              if (!cleaningUp) observer.error(error);\n            });\n\n          // Cleanup function.\n          return () => {\n            cleaningUp = true;\n\n            // Abort fetch. It’s ok to signal an abort even when not fetching.\n            if (controller) controller.abort();\n          };\n        }),\n    );\n  }\n}\n\n/**\n * Checks if a value is an extractable file.\n * @template [ExtractableFile=any] Extractable file.\n * @callback ExtractableFileMatcher\n * @param {unknown} value Value to check.\n * @returns {value is ExtractableFile} Is the value an extractable file.\n * @example\n * How to check for the default exactable files, as well as a custom type of\n * file:\n *\n * ```js\n * import isExtractableFile from \"apollo-upload-client/isExtractableFile.mjs\";\n *\n * const isExtractableFileEnhanced = (value) =>\n *   isExtractableFile(value) ||\n *   (typeof CustomFile !== \"undefined\" && value instanceof CustomFile);\n * ```\n */\n\n/**\n * Appends a file extracted from the GraphQL operation to the\n * [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * instance used as the\n * [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch)\n * `options.body` for the\n * [GraphQL multipart request](https://github.com/jaydenseric/graphql-multipart-request-spec).\n * @template [ExtractableFile=any] Extractable file.\n * @callback FormDataFileAppender\n * @param {FormData} formData\n *   [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n *   instance to append the specified file to.\n * @param {string} fieldName Form data field name to append the file with.\n * @param {ExtractableFile} file File to append. The file type depends on what\n *   the extractable file matcher extracts.\n */\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAe,SAAR,cAA+B,OAAO;AAC5C,MAAI,OAAO,UAAU,YAAY,UAAU,MAAM;AAChD,WAAO;AAAA,EACR;AAEA,QAAM,YAAY,OAAO,eAAe,KAAK;AAC7C,UAAQ,cAAc,QAAQ,cAAc,OAAO,aAAa,OAAO,eAAe,SAAS,MAAM,SAAS,EAAE,OAAO,eAAe,UAAU,EAAE,OAAO,YAAY;AACtK;;;ACsDe,SAAR,aAA8B,OAAO,eAAe,OAAO,IAAI;AACpE,MAAI,CAAC,UAAU,OAAQ,OAAM,IAAI,UAAU,iCAAiC;AAE5E,MAAI,OAAO,kBAAkB;AAC3B,UAAM,IAAI,UAAU,gDAAgD;AAEtE,MAAI,OAAO,SAAS;AAClB,UAAM,IAAI,UAAU,qCAAqC;AAmB3D,QAAM,SAAS,oBAAI,IAAI;AAMvB,QAAM,QAAQ,oBAAI,IAAI;AAUtB,WAAS,QAAQA,QAAOC,OAAM,UAAU;AACtC,QAAI,cAAcD,MAAK,GAAG;AACxB,YAAM,YAAY,MAAM,IAAIA,MAAK;AAEjC,kBAAY,UAAU,KAAKC,KAAI,IAAI,MAAM,IAAID,QAAO,CAACC,KAAI,CAAC;AAE1D,aAAO;AAAA,IACT;AAEA,UAAM,cACJ,MAAM,QAAQD,MAAK,KAClB,OAAO,aAAa,eAAeA,kBAAiB;AACvD,UAAM,qBAAqB,cAAcA,MAAK;AAE9C,QAAI,eAAe,oBAAoB;AACrC,UAAI,QAAQ,OAAO,IAAIA,MAAK;AAE5B,YAAM,WAAW,CAAC;AAElB,UAAI,UAAU;AACZ,gBAAQ,cACJ,CAAC;AAAA;AAAA,UAEHA;AAAA,UAAqC,SACnC,CAAC,IACD,uBAAO,OAAO,IAAI;AAAA;AAEtB,eAAO;AAAA,UAAIA;AAAA;AAAA,UAA6B;AAAA,QAAM;AAAA,MAChD;AAEA,UAAI,CAAC,SAAS,IAAIA,MAAK,GAAG;AACxB,cAAM,aAAaC,QAAO,GAAGA,KAAI,MAAM;AACvC,cAAM,iBAAiB,IAAI,IAAI,QAAQ,EAAE,IAAID,MAAK;AAElD,YAAI,aAAa;AACf,cAAI,QAAQ;AAEZ,qBAAW,QAAQA,QAAO;AACxB,kBAAM,YAAY;AAAA,cAChB;AAAA,cACA,aAAa;AAAA,cACb;AAAA,YACF;AAEA,gBAAI,SAAwC,CAAC,MAAO,KAAK,SAAS;AAAA,UACpE;AAAA,QACF;AACE,qBAAW,OAAOA,QAAO;AACvB,kBAAM,gBAAgB;AAAA,cACpBA,OAAM,GAAG;AAAA,cACT,aAAa;AAAA,cACb;AAAA,YACF;AAEA,gBAAI;AAC6C,cAAC,MAAO,GAAG,IACxD;AAAA,UACN;AAAA,MACJ;AAEA,aAAO;AAAA,IACT;AAEA,WAAOA;AAAA,EACT;AAEA,SAAO;AAAA,IACL,OAAO,QAAQ,OAAO,MAAM,oBAAI,IAAI,CAAC;AAAA,IACrC;AAAA,EACF;AACF;;;ACjKe,SAAR,mBAAoC,UAAU,WAAW,MAAM;AACpE,YAAU,OACN,SAAS,OAAO,WAAW,MAAM,KAAK,IAAI,IAC1C,SAAS,OAAO,WAAW,IAAI;AACrC;;;ACRe,SAAR,kBAAmC,OAAO;AAC/C,SACG,OAAO,SAAS,eAAe,iBAAiB,QAChD,OAAO,SAAS,eAAe,iBAAiB;AAErD;;;ACqCA,IAAqB,iBAArB,cAA4C,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoCrD,YAAY;AAAA,IACV,KAAK,WAAW;AAAA,IAChB;AAAA,IACA,mBAAmB,0BAA0B;AAAA,IAC7C,UAAU;AAAA,IACV,oBAAoB,2BAA2B;AAAA,IAC/C,QAAQ;AAAA,IACR,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,yBAAyB;AAAA,EAC3B,IAAI,CAAC,GAAG;AACN;AAAA,MACE,CAAC,cACC,IAAI,WAAW,CAAC,aAAa;AAC3B,cAAM,UAAU,UAAU,WAAW;AACrC,cAAM,EAAE,SAAS,KAAK,IAAI;AAAA,UACxB;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,YACE,MAAM;AAAA,cACJ;AAAA,YACF;AAAA,YACA,SAAS;AAAA,YACT;AAAA,YACA;AAAA,UACF;AAAA,UACA;AAAA,YACE,MAAM,QAAQ;AAAA,YACd,SAAS,QAAQ;AAAA,YACjB,aAAa,QAAQ;AAAA,YACrB,SAAS,QAAQ;AAAA,UACnB;AAAA,QACF;AAEA,YAAI,KAAK,aAAa,CAAC;AACrB,eAAK,YAAY;AAAA,YACf,KAAK;AAAA,YACL,UAAU;AAAA,UACZ;AAEF,cAAM,EAAE,OAAO,MAAM,IAAI;AAAA,UACvB;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAMA,YAAI,MAAM,UAAU,WAAW,QAAQ;AAEvC,YAAI,MAAM,MAAM;AACd,cAAI,QAAQ;AAGV,mBAAO,QAAQ,QAAQ,cAAc;AAKvC,gBAAM,kBAAkB,kBAAkB;AAE1C,gBAAM,OAAO,IAAI,gBAAgB;AAEjC,eAAK,OAAO,cAAc,KAAK,UAAU,KAAK,CAAC;AAG/C,gBAAM,MAAM,CAAC;AAEb,cAAI,IAAI;AACR,gBAAM,QAAQ,CAAC,UAAU;AACvB,gBAAI,EAAE,CAAC,IAAI;AAAA,UACb,CAAC;AACD,eAAK,OAAO,OAAO,KAAK,UAAU,GAAG,CAAC;AAEtC,cAAI;AACJ,gBAAM,QAAQ,CAAC,QAAQ,SAAS;AAC9B,qCAAyB,MAAM,OAAO,EAAE,CAAC,GAAG,IAAI;AAAA,UAClD,CAAC;AAED,kBAAQ,OAAO;AAAA,QACjB,OAAO;AACL,cACE;AAAA,UAEA,CAAC,UAAU,MAAM,YAAY;AAAA,YAC3B,CAAC,eACC,WAAW,SAAS,yBACpB,WAAW,cAAc;AAAA,UAC7B;AAEA,oBAAQ,SAAS;AAEnB,cAAI,QAAQ,WAAW,OAAO;AAC5B,kBAAM;AAAA;AAAA;AAAA;AAAA,cAIF,iBAAiB,KAAK,IAAI;AAAA;AAG9B,gBAAI,gBAAgB,OAAQ,OAAM,OAAO;AAEzC,kBAAM,OAAO;AAAA,UACf,MAAO,SAAQ,OAAO,KAAK,UAAU,KAAK;AAAA,QAC5C;AAMA,YAAI;AAEJ,YAAI,OAAO,oBAAoB,aAAa;AAC1C,uBAAa,IAAI,gBAAgB;AAEjC,cAAI,QAAQ;AAEV,oBAAQ,OAAO;AAAA;AAAA,cAEX,WAAW,MAAM;AAAA;AAAA;AAAA;AAAA,cAGjB,QAAQ,OAAO;AAAA,gBACb;AAAA,gBACA,MAAM;AACJ,6BAAW,MAAM;AAAA,gBACnB;AAAA,gBACA;AAAA;AAAA;AAAA;AAAA,kBAIE,MAAM;AAAA,gBACR;AAAA,cACF;AAAA;AAEN,kBAAQ,SAAS,WAAW;AAAA,QAC9B;AAQA,cAAM,eAAe,eAAe;AAMpC,YAAI;AAEJ,qBAAa,KAAK,OAAO,EACtB,KAAK,CAAC,aAAa;AAElB,oBAAU,WAAW,EAAE,SAAS,CAAC;AACjC,iBAAO;AAAA,QACT,CAAC,EACA,KAAK,0BAA0B,SAAS,CAAC,EACzC,KAAK,CAAC,WAAW;AAChB,mBAAS,KAAK,MAAM;AACpB,mBAAS,SAAS;AAAA,QACpB,CAAC,EACA,MAAM,CAAC,UAAU;AAKhB,cAAI,CAAC,WAAY,UAAS,MAAM,KAAK;AAAA,QACvC,CAAC;AAGH,eAAO,MAAM;AACX,uBAAa;AAGb,cAAI,WAAY,YAAW,MAAM;AAAA,QACnC;AAAA,MACF,CAAC;AAAA,IACL;AAAA,EACF;AACF;",
  "names": ["value", "path"]
}
